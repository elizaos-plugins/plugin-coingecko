{"version":3,"sources":["../src/actions/getMarkets.ts","../src/environment.ts","../src/providers/categoriesProvider.ts","../src/templates/markets.ts","../src/actions/getPrice.ts","../src/providers/coinsProvider.ts","../src/templates/price.ts","../src/actions/getPricePerAddress.ts","../src/templates/priceAddress.ts","../src/actions/getTopGainersLosers.ts","../src/templates/gainersLosers.ts","../src/actions/getTrending.ts","../src/templates/trending.ts","../src/actions/getTrendingPools.ts","../src/templates/trendingPools.ts","../src/actions/getNewlyListed.ts","../src/templates/newCoins.ts","../src/actions/getNetworkTrendingPools.ts","../src/templates/networkTrendingPools.ts","../src/providers/networkProvider.ts","../src/actions/getNetworkNewPools.ts","../src/templates/networkNewPools.ts","../src/index.ts"],"sourcesContent":["import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getCategoriesData } from '../providers/categoriesProvider';\nimport { getMarketsTemplate } from \"../templates/markets\";\n\ninterface CategoryItem {\n    category_id: string;\n    name: string;\n}\n\nexport function formatCategory(category: string | undefined, categories: CategoryItem[]): string | undefined {\n    if (!category) return undefined;\n\n    const normalizedInput = category.toLowerCase().trim();\n\n    // First try to find exact match by category_id\n    const exactMatch = categories.find(c => c.category_id === normalizedInput);\n    if (exactMatch) {\n        return exactMatch.category_id;\n    }\n\n    // Then try to find match by name\n    const nameMatch = categories.find(c =>\n        c.name.toLowerCase() === normalizedInput ||\n        c.name.toLowerCase().replace(/[^a-z0-9]+/g, '-') === normalizedInput\n    );\n    if (nameMatch) {\n        return nameMatch.category_id;\n    }\n\n    // Try to find partial matches\n    const partialMatch = categories.find(c =>\n        c.name.toLowerCase().includes(normalizedInput) ||\n        c.category_id.includes(normalizedInput)\n    );\n    if (partialMatch) {\n        return partialMatch.category_id;\n    }\n\n    return undefined;\n}\n\n/**\n * Interface for CoinGecko /coins/markets endpoint response\n * @see https://docs.coingecko.com/reference/coins-markets\n */\nexport interface CoinMarketData {\n    id: string;\n    symbol: string;\n    name: string;\n    image: string;\n    current_price: number;\n    market_cap: number;\n    market_cap_rank: number;\n    fully_diluted_valuation: number;\n    total_volume: number;\n    high_24h: number;\n    low_24h: number;\n    price_change_24h: number;\n    price_change_percentage_24h: number;\n    market_cap_change_24h: number;\n    market_cap_change_percentage_24h: number;\n    circulating_supply: number;\n    total_supply: number;\n    max_supply: number;\n    ath: number;\n    ath_change_percentage: number;\n    ath_date: string;\n    atl: number;\n    atl_change_percentage: number;\n    atl_date: string;\n    last_updated: string;\n}\n\nexport const GetMarketsSchema = z.object({\n    vs_currency: z.string().default('usd'),\n    category: z.string().optional(),\n    order: z.enum(['market_cap_desc', 'market_cap_asc', 'volume_desc', 'volume_asc']).default('market_cap_desc'),\n    per_page: z.number().min(1).max(250).default(20),\n    page: z.number().min(1).default(1),\n    sparkline: z.boolean().default(false)\n});\n\nexport type GetMarketsContent = z.infer<typeof GetMarketsSchema> & Content;\n\nexport const isGetMarketsContent = (obj: unknown): obj is GetMarketsContent => {\n    return GetMarketsSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_MARKETS\",\n    similes: [\n        \"MARKET_OVERVIEW\",\n        \"TOP_RANKINGS\",\n        \"MARKET_LEADERBOARD\",\n        \"CRYPTO_RANKINGS\",\n        \"BEST_PERFORMING_COINS\",\n        \"TOP_MARKET_CAPS\"\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    // Comprehensive endpoint for market rankings, supports up to 250 coins per request\n    description: \"Get ranked list of top cryptocurrencies sorted by market metrics (without specifying coins)\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_MARKETS handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            // Get categories through the provider\n            const categories = await getCategoriesData(runtime);\n\n            // Compose markets context with categories\n            const marketsContext = composeContext({\n                state: currentState,\n                template: getMarketsTemplate.replace('{{categories}}',\n                    categories.map(c => `- ${c.name} (ID: ${c.category_id})`).join('\\n')\n                ),\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: marketsContext,\n                modelClass: ModelClass.SMALL,\n                schema: GetMarketsSchema\n            });\n\n            if (!isGetMarketsContent(result.object)) {\n                elizaLogger.error(\"Invalid market data format received\");\n                return false;\n            }\n\n            const content = result.object;\n            elizaLogger.log(\"Content from template:\", content);\n\n            // If template returns null, this is not a markets request\n            if (!content) {\n                return false;\n            }\n\n            const formattedCategory = formatCategory(content.category, categories);\n            if (content.category && !formattedCategory) {\n                throw new Error(`Invalid category: ${content.category}. Please choose from the available categories.`);\n            }\n\n            elizaLogger.log(\"Making API request with params:\", {\n                url: `${baseUrl}/coins/markets`,\n                category: formattedCategory,\n                vs_currency: content.vs_currency,\n                order: content.order,\n                per_page: content.per_page,\n                page: content.page\n            });\n\n            const response = await axios.get<CoinMarketData[]>(\n                `${baseUrl}/coins/markets`,\n                {\n                    headers: {\n                        'accept': 'application/json',\n                        [headerKey]: apiKey\n                    },\n                    params: {\n                        vs_currency: content.vs_currency,\n                        category: formattedCategory,\n                        order: content.order,\n                        per_page: content.per_page,\n                        page: content.page,\n                        sparkline: content.sparkline\n                    }\n                }\n            );\n\n            if (!response.data?.length) {\n                throw new Error(\"No market data received from CoinGecko API\");\n            }\n\n            const formattedData = response.data.map(coin => ({\n                name: coin.name,\n                symbol: coin.symbol.toUpperCase(),\n                marketCapRank: coin.market_cap_rank,\n                currentPrice: coin.current_price,\n                priceChange24h: coin.price_change_24h,\n                priceChangePercentage24h: coin.price_change_percentage_24h,\n                marketCap: coin.market_cap,\n                volume24h: coin.total_volume,\n                high24h: coin.high_24h,\n                low24h: coin.low_24h,\n                circulatingSupply: coin.circulating_supply,\n                totalSupply: coin.total_supply,\n                maxSupply: coin.max_supply,\n                lastUpdated: coin.last_updated\n            }));\n\n            const categoryDisplay = content.category ?\n                `${categories.find(c => c.category_id === formattedCategory)?.name.toUpperCase() || content.category.toUpperCase()} ` : '';\n\n            const responseText = [\n                `Top ${formattedData.length} ${categoryDisplay}Cryptocurrencies by ${content.order === 'volume_desc' || content.order === 'volume_asc' ? 'Volume' : 'Market Cap'}:`,\n                ...formattedData.map((coin, index) =>\n                    `${index + 1}. ${coin.name} (${coin.symbol})` +\n                    ` | $${coin.currentPrice.toLocaleString()}` +\n                    ` | ${coin.priceChangePercentage24h.toFixed(2)}%` +\n                    ` | MCap: $${(coin.marketCap / 1e9).toFixed(2)}B`\n                )\n            ].join('\\n');\n\n            elizaLogger.success(\"Market data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        markets: formattedData,\n                        params: {\n                            vs_currency: content.vs_currency,\n                            category: content.category,\n                            order: content.order,\n                            per_page: content.per_page,\n                            page: content.page\n                        },\n                        timestamp: new Date().toISOString()\n                    }\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_MARKETS handler:\", error);\n\n            let errorMessage: string;\n            if (error.response?.status === 429) {\n                errorMessage = \"Rate limit exceeded. Please try again later.\";\n            } else if (error.response?.status === 403) {\n                errorMessage = \"This endpoint requires a CoinGecko Pro API key. Please upgrade your plan to access this data.\";\n            } else if (error.response?.status === 400) {\n                errorMessage = \"Invalid request parameters. Please check your input.\";\n            } else {\n                errorMessage = `Error fetching market data: ${error.message}`;\n            }\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    error: {\n                        message: error.message,\n                        statusCode: error.response?.status,\n                        params: error.config?.params,\n                        requiresProPlan: error.response?.status === 403\n                    }\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me the top cryptocurrencies by market cap\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the current market data for top cryptocurrencies.\",\n                    action: \"GET_MARKETS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the top cryptocurrencies:\\n1. Bitcoin (BTC) | $45,000 | +2.5% | MCap: $870.5B\\n{{dynamic}}\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import type { IAgentRuntime } from \"@elizaos/core\";\nimport { z } from \"zod\";\n\nconst coingeckoConfigSchema = z.object({\n    COINGECKO_API_KEY: z.string().nullable(),\n    COINGECKO_PRO_API_KEY: z.string().nullable(),\n}).refine(data => data.COINGECKO_API_KEY || data.COINGECKO_PRO_API_KEY, {\n    message: \"Either COINGECKO_API_KEY or COINGECKO_PRO_API_KEY must be provided\"\n});\n\nexport type CoingeckoConfig = z.infer<typeof coingeckoConfigSchema>;\n\nexport async function validateCoingeckoConfig(runtime: IAgentRuntime): Promise<CoingeckoConfig> {\n    const config = {\n        COINGECKO_API_KEY: runtime.getSetting(\"COINGECKO_API_KEY\"),\n        COINGECKO_PRO_API_KEY: runtime.getSetting(\"COINGECKO_PRO_API_KEY\"),\n    };\n\n    return coingeckoConfigSchema.parse(config);\n}\n\nexport function getApiConfig(config: CoingeckoConfig) {\n    const isPro = !!config.COINGECKO_PRO_API_KEY;\n    return {\n        baseUrl: isPro ? \"https://pro-api.coingecko.com/api/v3\" : \"https://api.coingecko.com/api/v3\",\n        apiKey: isPro ? config.COINGECKO_PRO_API_KEY : config.COINGECKO_API_KEY,\n        headerKey: isPro ? \"x-cg-pro-api-key\" : \"x-cg-demo-api-key\"\n    };\n}\n","import { type IAgentRuntime, type Memory, type Provider, type State, elizaLogger } from \"@elizaos/core\";\nimport axios from 'axios';\nimport { getApiConfig, validateCoingeckoConfig } from '../environment';\n\ninterface CategoryItem {\n    category_id: string;\n    name: string;\n}\n\nconst CACHE_KEY = 'coingecko:categories';\nconst CACHE_TTL = 5 * 60; // 5 minutes\nconst MAX_RETRIES = 3;\n\nasync function fetchCategories(runtime: IAgentRuntime): Promise<CategoryItem[]> {\n    const config = await validateCoingeckoConfig(runtime);\n    const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n    const response = await axios.get<CategoryItem[]>(\n        `${baseUrl}/coins/categories/list`,\n        {\n            headers: {\n                'accept': 'application/json',\n                [headerKey]: apiKey\n            },\n            timeout: 5000 // 5 second timeout\n        }\n    );\n\n    if (!response.data?.length) {\n        throw new Error(\"Invalid categories data received\");\n    }\n\n    return response.data;\n}\n\nasync function fetchWithRetry(runtime: IAgentRuntime): Promise<CategoryItem[]> {\n    let lastError: Error | null = null;\n\n    for (let i = 0; i < MAX_RETRIES; i++) {\n        try {\n            return await fetchCategories(runtime);\n        } catch (error) {\n            lastError = error;\n            elizaLogger.error(`Categories fetch attempt ${i + 1} failed:`, error);\n            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n    }\n\n    throw lastError || new Error(\"Failed to fetch categories after multiple attempts\");\n}\n\nasync function getCategories(runtime: IAgentRuntime): Promise<CategoryItem[]> {\n    try {\n        // Try to get from cache first\n        const cached = await runtime.cacheManager.get<CategoryItem[]>(CACHE_KEY);\n        if (cached) {\n            return cached;\n        }\n\n        // Fetch fresh data\n        const categories = await fetchWithRetry(runtime);\n\n        // Cache the result\n        await runtime.cacheManager.set(CACHE_KEY, categories, { expires: CACHE_TTL });\n\n        return categories;\n    } catch (error) {\n        elizaLogger.error(\"Error fetching categories:\", error);\n        throw error;\n    }\n}\n\nfunction formatCategoriesContext(categories: CategoryItem[]): string {\n    const popularCategories = [\n        'layer-1', 'defi', 'meme', 'ai-meme-coins',\n        'artificial-intelligence', 'gaming', 'metaverse'\n    ];\n\n    const popular = categories\n        .filter(c => popularCategories.includes(c.category_id))\n        .map(c => `${c.name} (${c.category_id})`);\n\n    return `\nAvailable cryptocurrency categories:\n\nPopular categories:\n${popular.map(c => `- ${c}`).join('\\n')}\n\nTotal available categories: ${categories.length}\n\nYou can use these category IDs when filtering cryptocurrency market data.\n`.trim();\n}\n\nexport const categoriesProvider: Provider = {\n    // eslint-disable-next-line\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<string> => {\n        try {\n            const categories = await getCategories(runtime);\n            return formatCategoriesContext(categories);\n        } catch (error) {\n            elizaLogger.error(\"Categories provider error:\", error);\n            return \"Cryptocurrency categories are temporarily unavailable. Please try again later.\";\n        }\n    }\n};\n\n// Helper function for actions to get raw categories data\nexport async function getCategoriesData(runtime: IAgentRuntime): Promise<CategoryItem[]> {\n    return getCategories(runtime);\n}\n","export const getMarketsTemplate = `\nExtract the following parameters for market listing:\n- **vs_currency** (string): Target currency for price data (default: \"usd\")\n- **category** (string, optional): Specific category ID from the available categories\n- **per_page** (number): Number of results to return (1-250, default: 20)\n- **order** (string): Sort order for results, one of:\n  - market_cap_desc: Highest market cap first\n  - market_cap_asc: Lowest market cap first\n  - volume_desc: Highest volume first\n  - volume_asc: Lowest volume first\n\nAvailable Categories:\n{{categories}}\n\nProvide the values in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"vs_currency\": \"<currency>\",\n    \"category\": \"<category_id>\",\n    \"per_page\": <number>,\n    \"order\": \"<sort_order>\",\n    \"page\": 1,\n    \"sparkline\": false\n}\n\\`\\`\\`\n\nExample request: \"Show me the top 10 gaming cryptocurrencies\"\nExample response:\n\\`\\`\\`json\n{\n    \"vs_currency\": \"usd\",\n    \"category\": \"gaming\",\n    \"per_page\": 10,\n    \"order\": \"market_cap_desc\",\n    \"page\": 1,\n    \"sparkline\": false\n}\n\\`\\`\\`\n\nExample request: \"What are the best performing coins by volume?\"\nExample response:\n\\`\\`\\`json\n{\n    \"vs_currency\": \"usd\",\n    \"per_page\": 20,\n    \"order\": \"volume_desc\",\n    \"page\": 1,\n    \"sparkline\": false\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nBased on the conversation above, if the request is for a market listing/ranking, extract the appropriate parameters and respond with a JSON object. If the request is for specific coins only, respond with null.`;","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getCoinsData } from \"../providers/coinsProvider\";\nimport { getPriceTemplate } from \"../templates/price\";\n\ninterface CurrencyData {\n    [key: string]: number;\n    usd?: number;\n    eur?: number;\n    usd_market_cap?: number;\n    eur_market_cap?: number;\n    usd_24h_vol?: number;\n    eur_24h_vol?: number;\n    usd_24h_change?: number;\n    eur_24h_change?: number;\n    last_updated_at?: number;\n}\n\ninterface PriceResponse {\n    [coinId: string]: CurrencyData;\n}\n\nexport const GetPriceSchema = z.object({\n    coinIds: z.union([z.string(), z.array(z.string())]),\n    currency: z.union([z.string(), z.array(z.string())]).default([\"usd\"]),\n    include_market_cap: z.boolean().default(false),\n    include_24hr_vol: z.boolean().default(false),\n    include_24hr_change: z.boolean().default(false),\n    include_last_updated_at: z.boolean().default(false)\n});\n\nexport type GetPriceContent = z.infer<typeof GetPriceSchema> & Content;\n\nexport const isGetPriceContent = (obj: unknown): obj is GetPriceContent => {\n    return GetPriceSchema.safeParse(obj).success;\n};\n\nfunction formatCoinIds(input: string | string[]): string {\n    if (Array.isArray(input)) {\n        return input.join(',');\n    }\n    return input;\n}\n\nexport default {\n    name: \"GET_PRICE\",\n    similes: [\n        \"COIN_PRICE_CHECK\",\n        \"SPECIFIC_COINS_PRICE\",\n        \"COIN_PRICE_LOOKUP\",\n        \"SELECTED_COINS_PRICE\",\n        \"PRICE_DETAILS\",\n        \"COIN_PRICE_DATA\"\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description: \"Get price and basic market data for one or more specific cryptocurrencies (by name/symbol)\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_PRICE handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            elizaLogger.log(\"Composing price context...\");\n            const priceContext = composeContext({\n                state: currentState,\n                template: getPriceTemplate,\n            });\n\n            elizaLogger.log(\"Generating content from template...\");\n            const result = await generateObject({\n                runtime,\n                context: priceContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetPriceSchema\n            });\n\n            if (!isGetPriceContent(result.object)) {\n                elizaLogger.error(\"Invalid price request format\");\n                return false;\n            }\n\n            const content = result.object;\n            elizaLogger.log(\"Generated content:\", content);\n\n            // Format currencies for API request\n            const currencies = Array.isArray(content.currency) ? content.currency : [content.currency];\n            const vs_currencies = currencies.join(',').toLowerCase();\n\n            // Format coin IDs for API request\n            const coinIds = formatCoinIds(content.coinIds);\n\n            elizaLogger.log(\"Formatted request parameters:\", { coinIds, vs_currencies });\n\n            // Fetch price from CoinGecko\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(`Fetching prices for ${coinIds} in ${vs_currencies}...`);\n            elizaLogger.log(\"API request URL:\", `${baseUrl}/simple/price`);\n            elizaLogger.log(\"API request params:\", {\n                ids: coinIds,\n                vs_currencies,\n                include_market_cap: content.include_market_cap,\n                include_24hr_vol: content.include_24hr_vol,\n                include_24hr_change: content.include_24hr_change,\n                include_last_updated_at: content.include_last_updated_at\n            });\n\n            const response = await axios.get<PriceResponse>(\n                `${baseUrl}/simple/price`,\n                {\n                    params: {\n                        ids: coinIds,\n                        vs_currencies,\n                        include_market_cap: content.include_market_cap,\n                        include_24hr_vol: content.include_24hr_vol,\n                        include_24hr_change: content.include_24hr_change,\n                        include_last_updated_at: content.include_last_updated_at\n                    },\n                    headers: {\n                        'accept': 'application/json',\n                        [headerKey]: apiKey\n                    }\n                }\n            );\n\n            if (Object.keys(response.data).length === 0) {\n                throw new Error(\"No price data available for the specified coins and currency\");\n            }\n\n            // Get coins data for formatting\n            const coins = await getCoinsData(runtime);\n\n            // Format response text for each coin\n            const formattedResponse = Object.entries(response.data).map(([coinId, data]) => {\n                const coin = coins.find(c => c.id === coinId);\n                const coinName = coin ? `${coin.name} (${coin.symbol.toUpperCase()})` : coinId;\n                const parts = [`${coinName}:`];\n\n                // Add price for each requested currency\n                for (const currency of currencies) {\n                    const upperCurrency = currency.toUpperCase();\n                    if (data[currency]) {\n                        parts.push(`  ${upperCurrency}: ${data[currency].toLocaleString(undefined, {\n                            style: 'currency',\n                            currency: currency\n                        })}`);\n                    }\n\n                    // Add market cap if requested and available\n                    if (content.include_market_cap) {\n                        const marketCap = data[`${currency}_market_cap`];\n                        if (marketCap !== undefined) {\n                            parts.push(`  Market Cap (${upperCurrency}): ${marketCap.toLocaleString(undefined, {\n                                style: 'currency',\n                                currency: currency,\n                                maximumFractionDigits: 0\n                            })}`);\n                        }\n                    }\n\n                    // Add 24h volume if requested and available\n                    if (content.include_24hr_vol) {\n                        const volume = data[`${currency}_24h_vol`];\n                        if (volume !== undefined) {\n                            parts.push(`  24h Volume (${upperCurrency}): ${volume.toLocaleString(undefined, {\n                                style: 'currency',\n                                currency: currency,\n                                maximumFractionDigits: 0\n                            })}`);\n                        }\n                    }\n\n                    // Add 24h change if requested and available\n                    if (content.include_24hr_change) {\n                        const change = data[`${currency}_24h_change`];\n                        if (change !== undefined) {\n                            const changePrefix = change >= 0 ? '+' : '';\n                            parts.push(`  24h Change (${upperCurrency}): ${changePrefix}${change.toFixed(2)}%`);\n                        }\n                    }\n                }\n\n                // Add last updated if requested\n                if (content.include_last_updated_at && data.last_updated_at) {\n                    const lastUpdated = new Date(data.last_updated_at * 1000).toLocaleString();\n                    parts.push(`  Last Updated: ${lastUpdated}`);\n                }\n\n                return parts.join('\\n');\n            }).filter(Boolean);\n\n            if (formattedResponse.length === 0) {\n                throw new Error(\"Failed to format price data for the specified coins\");\n            }\n\n            const responseText = formattedResponse.join('\\n\\n');\n            elizaLogger.success(\"Price data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        prices: Object.entries(response.data).reduce((acc, [coinId, data]) => {\n                            const coinPrices = currencies.reduce((currencyAcc, currency) => {\n                                const currencyData = {\n                                    price: data[currency],\n                                    marketCap: data[`${currency}_market_cap`],\n                                    volume24h: data[`${currency}_24h_vol`],\n                                    change24h: data[`${currency}_24h_change`],\n                                    lastUpdated: data.last_updated_at,\n                                };\n                                Object.assign(currencyAcc, { [currency]: currencyData });\n                                return currencyAcc;\n                            }, {});\n                            Object.assign(acc, { [coinId]: coinPrices });\n                            return acc;\n                        }, {}),\n                        params: {\n                            currencies: currencies.map(c => c.toUpperCase()),\n                            include_market_cap: content.include_market_cap,\n                            include_24hr_vol: content.include_24hr_vol,\n                            include_24hr_change: content.include_24hr_change,\n                            include_last_updated_at: content.include_last_updated_at\n                        }\n                    }\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_PRICE handler:\", error);\n\n            let errorMessage: string;\n            if (error.response?.status === 429) {\n                errorMessage = \"Rate limit exceeded. Please try again later.\";\n            } else if (error.response?.status === 403) {\n                errorMessage = \"This endpoint requires a CoinGecko Pro API key. Please upgrade your plan to access this data.\";\n            } else if (error.response?.status === 400) {\n                errorMessage = \"Invalid request parameters. Please check your input.\";\n            }\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                        params: error.config?.params,\n                        requiresProPlan: error.response?.status === 403\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's the current price of Bitcoin?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the current Bitcoin price for you.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"The current price of Bitcoin is {{dynamic}} USD\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Check ETH and BTC prices in EUR with market cap\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the current prices with market cap data.\",\n                    action: \"GET_PRICE\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Bitcoin: EUR {{dynamic}} | Market Cap: €{{dynamic}}\\nEthereum: EUR {{dynamic}} | Market Cap: €{{dynamic}}\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","import { type IAgentRuntime, type Memory, type Provider, type State, elizaLogger } from \"@elizaos/core\";\nimport axios from 'axios';\nimport { getApiConfig, validateCoingeckoConfig } from '../environment';\n\ninterface CoinItem {\n    id: string;\n    symbol: string;\n    name: string;\n}\n\nconst CACHE_KEY = 'coingecko:coins';\nconst CACHE_TTL = 5 * 60; // 5 minutes\nconst MAX_RETRIES = 3;\n\nasync function fetchCoins(runtime: IAgentRuntime, includePlatform = false): Promise<CoinItem[]> {\n    const config = await validateCoingeckoConfig(runtime);\n    const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n    const response = await axios.get<CoinItem[]>(\n        `${baseUrl}/coins/list`,\n        {\n            params: {\n                include_platform: includePlatform\n            },\n            headers: {\n                'accept': 'application/json',\n                [headerKey]: apiKey\n            },\n            timeout: 5000 // 5 second timeout\n        }\n    );\n\n    if (!response.data?.length) {\n        throw new Error(\"Invalid coins data received\");\n    }\n\n    return response.data;\n}\n\nasync function fetchWithRetry(runtime: IAgentRuntime, includePlatform = false): Promise<CoinItem[]> {\n    let lastError: Error | null = null;\n\n    for (let i = 0; i < MAX_RETRIES; i++) {\n        try {\n            return await fetchCoins(runtime, includePlatform);\n        } catch (error) {\n            lastError = error;\n            elizaLogger.error(`Coins fetch attempt ${i + 1} failed:`, error);\n            await new Promise(resolve => setTimeout(resolve, 1000 * (i + 1)));\n        }\n    }\n\n    throw lastError || new Error(\"Failed to fetch coins after multiple attempts\");\n}\n\nasync function getCoins(runtime: IAgentRuntime, includePlatform = false): Promise<CoinItem[]> {\n    try {\n        // Try to get from cache first\n        const cached = await runtime.cacheManager.get<CoinItem[]>(CACHE_KEY);\n        if (cached) {\n            return cached;\n        }\n\n        // Fetch fresh data\n        const coins = await fetchWithRetry(runtime, includePlatform);\n\n        // Cache the result\n        await runtime.cacheManager.set(CACHE_KEY, coins, { expires: CACHE_TTL });\n\n        return coins;\n    } catch (error) {\n        elizaLogger.error(\"Error fetching coins:\", error);\n        throw error;\n    }\n}\n\nfunction formatCoinsContext(coins: CoinItem[]): string {\n    const popularCoins = [\n        'bitcoin', 'ethereum', 'binancecoin', 'ripple',\n        'cardano', 'solana', 'polkadot', 'dogecoin'\n    ];\n\n    const popular = coins\n        .filter(c => popularCoins.includes(c.id))\n        .map(c => `${c.name} (${c.symbol.toUpperCase()}) - ID: ${c.id}`);\n\n    return `\nAvailable cryptocurrencies:\n\nPopular coins:\n${popular.map(c => `- ${c}`).join('\\n')}\n\nTotal available coins: ${coins.length}\n\nYou can use these coin IDs when querying specific cryptocurrency data.\n`.trim();\n}\n\nexport const coinsProvider: Provider = {\n    // eslint-disable-next-line\n    get: async (runtime: IAgentRuntime, message: Memory, state?: State): Promise<string> => {\n        try {\n            const coins = await getCoins(runtime);\n            return formatCoinsContext(coins);\n        } catch (error) {\n            elizaLogger.error(\"Coins provider error:\", error);\n            return \"Cryptocurrency list is temporarily unavailable. Please try again later.\";\n        }\n    }\n};\n\n// Helper function for actions to get raw coins data\nexport async function getCoinsData(runtime: IAgentRuntime, includePlatform = false): Promise<CoinItem[]> {\n    return getCoins(runtime, includePlatform);\n}\n","export const getPriceTemplate = `\nExtract the following parameters for cryptocurrency price data:\n- **coinIds** (string | string[]): The ID(s) of the cryptocurrency/cryptocurrencies to get prices for (e.g., \"bitcoin\" or [\"bitcoin\", \"ethereum\"])\n- **currency** (string | string[]): The currency/currencies to display prices in (e.g., \"usd\" or [\"usd\", \"eur\", \"jpy\"]) - defaults to [\"usd\"]\n- **include_market_cap** (boolean): Whether to include market cap data - defaults to false\n- **include_24hr_vol** (boolean): Whether to include 24h volume data - defaults to false\n- **include_24hr_change** (boolean): Whether to include 24h price change data - defaults to false\n- **include_last_updated_at** (boolean): Whether to include last update timestamp - defaults to false\n\nProvide the values in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"coinIds\": \"bitcoin\",\n    \"currency\": [\"usd\"],\n    \"include_market_cap\": false,\n    \"include_24hr_vol\": false,\n    \"include_24hr_change\": false,\n    \"include_last_updated_at\": false\n}\n\\`\\`\\`\n\nExample request: \"What's the current price of Bitcoin?\"\nExample response:\n\\`\\`\\`json\n{\n    \"coinIds\": \"bitcoin\",\n    \"currency\": [\"usd\"],\n    \"include_market_cap\": false,\n    \"include_24hr_vol\": false,\n    \"include_24hr_change\": false,\n    \"include_last_updated_at\": false\n}\n\\`\\`\\`\n\nExample request: \"Show me ETH price and market cap in EUR with last update time\"\nExample response:\n\\`\\`\\`json\n{\n    \"coinIds\": \"ethereum\",\n    \"currency\": [\"eur\"],\n    \"include_market_cap\": true,\n    \"include_24hr_vol\": false,\n    \"include_24hr_change\": false,\n    \"include_last_updated_at\": true\n}\n\\`\\`\\`\n\nExample request: \"What's the current price of Bitcoin in USD, JPY and EUR?\"\nExample response:\n\\`\\`\\`json\n{\n    \"coinIds\": \"bitcoin\",\n    \"currency\": [\"usd\", \"jpy\", \"eur\"],\n    \"include_market_cap\": false,\n    \"include_24hr_vol\": false,\n    \"include_24hr_change\": false,\n    \"include_last_updated_at\": false\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nBased on the conversation above, if the request is for cryptocurrency price data, extract the appropriate parameters and respond with a JSON object. If the request is not related to price data, respond with null.`;\n","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getPriceByAddressTemplate } from \"../templates/priceAddress\";\n\n// Schema definition for the token price request\nexport const GetTokenPriceSchema = z.object({\n    chainId: z.string(),\n    tokenAddress: z.string(),\n});\n\nexport type GetTokenPriceContent = z.infer<typeof GetTokenPriceSchema> &\n    Content;\n\nexport const isGetTokenPriceContent = (\n    obj: unknown\n): obj is GetTokenPriceContent => {\n    return GetTokenPriceSchema.safeParse(obj).success;\n};\n\ninterface TokenResponse {\n    id: string;\n    symbol: string;\n    name: string;\n    market_data: {\n        current_price: {\n            usd: number;\n        };\n        market_cap: {\n            usd: number;\n        };\n    };\n}\n\nexport default {\n    name: \"GET_TOKEN_PRICE_BY_ADDRESS\",\n    similes: [\n        \"FETCH_TOKEN_PRICE_BY_ADDRESS\",\n        \"CHECK_TOKEN_PRICE_BY_ADDRESS\",\n        \"LOOKUP_TOKEN_BY_ADDRESS\",\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description:\n        \"Get the current USD price for a token using its blockchain address\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting GET_TOKEN_PRICE_BY_ADDRESS handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            elizaLogger.log(\"Composing token price context...\");\n            const context = composeContext({\n                state: currentState,\n                template: getPriceByAddressTemplate,\n            });\n\n            elizaLogger.log(\"Generating content from template...\");\n            const result = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.SMALL,\n                schema: GetTokenPriceSchema,\n            });\n\n            if (!isGetTokenPriceContent(result.object)) {\n                elizaLogger.error(\"Invalid token price request format\");\n                return false;\n            }\n\n            const content = result.object;\n            elizaLogger.log(\"Generated content:\", content);\n\n            // Get API configuration\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            // Fetch token data\n            elizaLogger.log(\"Fetching token data...\");\n            const response = await axios.get<TokenResponse>(\n                `${baseUrl}/coins/${content.chainId}/contract/${content.tokenAddress}`,\n                {\n                    headers: {\n                        accept: \"application/json\",\n                        [headerKey]: apiKey,\n                    },\n                }\n            );\n\n            const tokenData = response.data;\n            if (!tokenData.market_data?.current_price?.usd) {\n                throw new Error(\n                    `No price data available for token ${content.tokenAddress} on ${content.chainId}`\n                );\n            }\n\n            // Format response\n            const parts = [\n                `${tokenData.name} (${tokenData.symbol.toUpperCase()})`,\n                `Address: ${content.tokenAddress}`,\n                `Chain: ${content.chainId}`,\n                `Price: $${tokenData.market_data.current_price.usd.toFixed(6)} USD`,\n            ];\n\n            if (tokenData.market_data.market_cap?.usd) {\n                parts.push(\n                    `Market Cap: $${tokenData.market_data.market_cap.usd.toLocaleString()} USD`\n                );\n            }\n\n            const responseText = parts.join(\"\\n\");\n            elizaLogger.success(\"Token price data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        token: {\n                            name: tokenData.name,\n                            symbol: tokenData.symbol,\n                            address: content.tokenAddress,\n                            chain: content.chainId,\n                            price: tokenData.market_data.current_price.usd,\n                            marketCap: tokenData.market_data.market_cap?.usd,\n                        },\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in GET_TOKEN_PRICE_BY_ADDRESS handler:\",\n                error\n            );\n\n            let errorMessage: string;\n            if (error.response?.status === 429) {\n                errorMessage = \"Rate limit exceeded. Please try again later.\";\n            } else if (error.response?.status === 403) {\n                errorMessage =\n                    \"This endpoint requires a CoinGecko Pro API key. Please upgrade your plan to access this data.\";\n            } else if (error.response?.status === 400) {\n                errorMessage =\n                    \"Invalid request parameters. Please check your input.\";\n            } else {\n                errorMessage =\n                    \"Failed to fetch token price. Please try again later.\";\n            }\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                        requiresProPlan: error.response?.status === 403,\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What's the price of the USDC token on Ethereum? The address is 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the USDC token price for you.\",\n                    action: \"GET_TOKEN_PRICE_BY_ADDRESS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"USD Coin (USDC)\\nAddress: 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\\nChain: ethereum\\nPrice: {{dynamic}} USD\\nMarket Cap: ${{dynamic}} USD\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getPriceByAddressTemplate = `\nExtract the following parameters for token price data:\n- **chainId** (string): The blockchain network ID (e.g., \"ethereum\", \"polygon\", \"binance-smart-chain\")\n- **tokenAddress** (string): The contract address of the token\n- **include_market_cap** (boolean): Whether to include market cap data - defaults to true\n\nNormalize chain IDs to lowercase names: ethereum, polygon, binance-smart-chain, avalanche, fantom, arbitrum, optimism, etc.\nToken address should be the complete address string, maintaining its original case.\n\nProvide the values in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"chainId\": \"ethereum\",\n    \"tokenAddress\": \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n    \"include_market_cap\": true\n}\n\\`\\`\\`\n\nExample request: \"What's the price of USDC on Ethereum? Address: 0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\"\nExample response:\n\\`\\`\\`json\n{\n    \"chainId\": \"ethereum\",\n    \"tokenAddress\": \"0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48\",\n    \"include_market_cap\": true\n}\n\\`\\`\\`\n\nExample request: \"Check the price for this token on Polygon: 0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\"\nExample response:\n\\`\\`\\`json\n{\n    \"chainId\": \"polygon\",\n    \"tokenAddress\": \"0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\",\n    \"include_market_cap\": true\n}\n\\`\\`\\`\n\nExample request: \"Get price for BONK token on Solana with address HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC\"\nExample response:\n\\`\\`\\`json\n{\n    \"chainId\": \"solana\",\n    \"tokenAddress\": \"HeLp6NuQkmYB4pYWo2zYs22mESHXPQYzXbB8n4V98jwC\"\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nBased on the conversation above, use last question made and if the request is for token price data and includes both a chain and address, extract the appropriate parameters and respond with a JSON object. If the request is not related to token price data or missing required information, respond with null.`;\n","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getTopGainersLosersTemplate } from \"../templates/gainersLosers\";\n\ninterface TopGainerLoserItem {\n    id: string;\n    symbol: string;\n    name: string;\n    image: string;\n    market_cap_rank: number;\n    usd: number;\n    usd_24h_vol: number;\n    usd_1h_change?: number;\n    usd_24h_change?: number;\n    usd_7d_change?: number;\n    usd_14d_change?: number;\n    usd_30d_change?: number;\n    usd_60d_change?: number;\n    usd_1y_change?: number;\n}\n\ninterface TopGainersLosersResponse {\n    top_gainers: TopGainerLoserItem[];\n    top_losers: TopGainerLoserItem[];\n}\n\nconst DurationEnum = z.enum([\"1h\", \"24h\", \"7d\", \"14d\", \"30d\", \"60d\", \"1y\"]);\n//type Duration = z.infer<typeof DurationEnum>;\n\nexport const GetTopGainersLosersSchema = z.object({\n    vs_currency: z.string().default(\"usd\"),\n    duration: DurationEnum.default(\"24h\"),\n    top_coins: z.string().default(\"1000\")\n});\n\nexport type GetTopGainersLosersContent = z.infer<typeof GetTopGainersLosersSchema> & Content;\n\nexport const isGetTopGainersLosersContent = (obj: unknown): obj is GetTopGainersLosersContent => {\n    return GetTopGainersLosersSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_TOP_GAINERS_LOSERS\",\n    similes: [\n        \"TOP_MOVERS\",\n        \"BIGGEST_GAINERS\",\n        \"BIGGEST_LOSERS\",\n        \"PRICE_CHANGES\",\n        \"BEST_WORST_PERFORMERS\",\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description: \"Get list of top gaining and losing cryptocurrencies by price change\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_TOP_GAINERS_LOSERS handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            elizaLogger.log(\"Composing gainers/losers context...\");\n            const context = composeContext({\n                state: currentState,\n                template: getTopGainersLosersTemplate,\n            });\n\n            elizaLogger.log(\"Generating content from template...\");\n            const result = await generateObject({\n                runtime,\n                context,\n                modelClass: ModelClass.LARGE,\n                schema: GetTopGainersLosersSchema\n            });\n\n            if (!isGetTopGainersLosersContent(result.object)) {\n                elizaLogger.error(\"Invalid gainers/losers request format\");\n                return false;\n            }\n\n            const content = result.object;\n            elizaLogger.log(\"Generated content:\", content);\n\n            // Fetch data from CoinGecko\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\"Fetching top gainers/losers data...\");\n            elizaLogger.log(\"API request params:\", {\n                vs_currency: content.vs_currency,\n                duration: content.duration,\n                top_coins: content.top_coins\n            });\n\n            const response = await axios.get<TopGainersLosersResponse>(\n                `${baseUrl}/coins/top_gainers_losers`,\n                {\n                    headers: {\n                        'accept': 'application/json',\n                        [headerKey]: apiKey\n                    },\n                    params: {\n                        vs_currency: content.vs_currency,\n                        duration: content.duration,\n                        top_coins: content.top_coins\n                    }\n                }\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            // Format the response text\n            const responseText = [\n                'Top Gainers:',\n                ...response.data.top_gainers.map((coin, index) => {\n                    const changeKey = `usd_${content.duration}_change` as keyof TopGainerLoserItem;\n                    const change = coin[changeKey] as number;\n                    return `${index + 1}. ${coin.name} (${coin.symbol.toUpperCase()})` +\n                        ` | $${coin.usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 8 })}` +\n                        ` | ${change >= 0 ? '+' : ''}${change.toFixed(2)}%` +\n                        `${coin.market_cap_rank ? ` | Rank #${coin.market_cap_rank}` : ''}`;\n                }),\n                '',\n                'Top Losers:',\n                ...response.data.top_losers.map((coin, index) => {\n                    const changeKey = `usd_${content.duration}_change` as keyof TopGainerLoserItem;\n                    const change = coin[changeKey] as number;\n                    return `${index + 1}. ${coin.name} (${coin.symbol.toUpperCase()})` +\n                        ` | $${coin.usd.toLocaleString(undefined, { minimumFractionDigits: 2, maximumFractionDigits: 8 })}` +\n                        ` | ${change >= 0 ? '+' : ''}${change.toFixed(2)}%` +\n                        `${coin.market_cap_rank ? ` | Rank #${coin.market_cap_rank}` : ''}`;\n                })\n            ].join('\\n');\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        data: response.data,\n                        params: {\n                            vs_currency: content.vs_currency,\n                            duration: content.duration,\n                            top_coins: content.top_coins\n                        }\n                    }\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_TOP_GAINERS_LOSERS handler:\", error);\n\n            let errorMessage: string;\n            if (error.response?.status === 429) {\n                errorMessage = \"Rate limit exceeded. Please try again later.\";\n            } else if (error.response?.status === 403) {\n                errorMessage = \"This endpoint requires a CoinGecko Pro API key. Please upgrade your plan to access this data.\";\n            } else if (error.response?.status === 400) {\n                errorMessage = \"Invalid request parameters. Please check your input.\";\n            } else {\n                errorMessage = `Error fetching top gainers/losers data: ${error.message}`;\n            }\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                        params: error.config?.params,\n                        requiresProPlan: error.response?.status === 403\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the top gaining and losing cryptocurrencies?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the top gainers and losers for you.\",\n                    action: \"GET_TOP_GAINERS_LOSERS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the top gainers and losers:\\nTop Gainers:\\n1. Bitcoin (BTC) | $45,000 | +5.2% | Rank #1\\n{{dynamic}}\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me the best and worst performing crypto today\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the current top movers in the crypto market.\",\n                    action: \"GET_TOP_GAINERS_LOSERS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are today's best and worst performers:\\n{{dynamic}}\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;","export const getTopGainersLosersTemplate = `\nExtract the following parameters for top gainers and losers data:\n- **vs_currency** (string): The target currency to display prices in (e.g., \"usd\", \"eur\") - defaults to \"usd\"\n- **duration** (string): Time range for price changes - one of \"24h\", \"7d\", \"14d\", \"30d\", \"60d\", \"1y\" - defaults to \"24h\"\n- **top_coins** (string): Filter by market cap ranking (e.g., \"100\", \"1000\") - defaults to \"1000\"\n\nProvide the values in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"vs_currency\": \"usd\",\n    \"duration\": \"24h\",\n    \"top_coins\": \"1000\"\n}\n\\`\\`\\`\n\nExample request: \"Show me the biggest gainers and losers today\"\nExample response:\n\\`\\`\\`json\n{\n    \"vs_currency\": \"usd\",\n    \"duration\": \"24h\",\n    \"top_coins\": \"1000\"\n}\n\\`\\`\\`\n\nExample request: \"What are the top movers in EUR for the past week?\"\nExample response:\n\\`\\`\\`json\n{\n    \"vs_currency\": \"eur\",\n    \"duration\": \"7d\",\n    \"top_coins\": \"300\"\n}\n\\`\\`\\`\n\nExample request: \"Show me monthly performance of top 100 coins\"\nExample response:\n\\`\\`\\`json\n{\n    \"vs_currency\": \"usd\",\n    \"duration\": \"30d\",\n    \"top_coins\": \"100\"\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nBased on the conversation above, if the request is for top gainers and losers data, extract the appropriate parameters and respond with a JSON object. If the request is not related to top movers data, respond with null.`;","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getTrendingTemplate } from \"../templates/trending\";\n\ninterface TrendingCoinItem {\n    id: string;\n    name: string;\n    api_symbol: string;\n    symbol: string;\n    market_cap_rank: number;\n    thumb: string;\n    large: string;\n}\n\ninterface TrendingExchange {\n    id: string;\n    name: string;\n    market_type: string;\n    thumb: string;\n    large: string;\n}\n\ninterface TrendingCategory {\n    id: string;\n    name: string;\n}\n\ninterface TrendingNFT {\n    id: string;\n    name: string;\n    symbol: string;\n    thumb: string;\n}\n\ninterface TrendingResponse {\n    coins: Array<{ item: TrendingCoinItem }>;\n    exchanges: TrendingExchange[];\n    categories: TrendingCategory[];\n    nfts: TrendingNFT[];\n    icos: string[];\n}\n\nexport const GetTrendingSchema = z.object({\n    include_nfts: z.boolean().default(true),\n    include_categories: z.boolean().default(true)\n});\n\nexport type GetTrendingContent = z.infer<typeof GetTrendingSchema> & Content;\n\nexport const isGetTrendingContent = (obj: unknown): obj is GetTrendingContent => {\n    return GetTrendingSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_TRENDING\",\n    similes: [\n        \"TRENDING_COINS\",\n        \"TRENDING_CRYPTO\",\n        \"HOT_COINS\",\n        \"POPULAR_COINS\",\n        \"TRENDING_SEARCH\",\n    ],\n    // eslint-disable-next-line\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description: \"Get list of trending cryptocurrencies, NFTs, and categories from CoinGecko\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_TRENDING handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            // Compose trending context\n            elizaLogger.log(\"Composing trending context...\");\n            const trendingContext = composeContext({\n                state: currentState,\n                template: getTrendingTemplate,\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: trendingContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetTrendingSchema\n            });\n\n            if (!isGetTrendingContent(result.object)) {\n                elizaLogger.error(\"Invalid trending request format\");\n                return false;\n            }\n\n            // Fetch trending data from CoinGecko\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\"Fetching trending data...\");\n\n            const response = await axios.get<TrendingResponse>(\n                `${baseUrl}/search/trending`,\n                {\n                    headers: {\n                        [headerKey]: apiKey\n                    }\n                }\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            const formattedData = {\n                coins: response.data.coins.map(({ item }) => ({\n                    name: item.name,\n                    symbol: item.symbol.toUpperCase(),\n                    marketCapRank: item.market_cap_rank,\n                    id: item.id,\n                    thumbnail: item.thumb,\n                    largeImage: item.large\n                })),\n                nfts: response.data.nfts.map(nft => ({\n                    name: nft.name,\n                    symbol: nft.symbol,\n                    id: nft.id,\n                    thumbnail: nft.thumb\n                })),\n                categories: response.data.categories.map(category => ({\n                    name: category.name,\n                    id: category.id\n                }))\n            };\n\n            const responseText = [\n                'Trending Coins:',\n                ...formattedData.coins.map((coin, index) =>\n                    `${index + 1}. ${coin.name} (${coin.symbol})${coin.marketCapRank ? ` - Rank #${coin.marketCapRank}` : ''}`\n                ),\n                '',\n                'Trending NFTs:',\n                ...(formattedData.nfts.length ?\n                    formattedData.nfts.map((nft, index) => `${index + 1}. ${nft.name} (${nft.symbol})`) :\n                    ['No trending NFTs available']),\n                '',\n                'Trending Categories:',\n                ...(formattedData.categories.length ?\n                    formattedData.categories.map((category, index) => `${index + 1}. ${category.name}`) :\n                    ['No trending categories available'])\n            ].join('\\n');\n\n            elizaLogger.success(\"Trending data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        trending: formattedData,\n                        timestamp: new Date().toISOString()\n                    }\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_TRENDING handler:\", error);\n\n            // Enhanced error handling\n            const errorMessage = error.response?.status === 429 ?\n                \"Rate limit exceeded. Please try again later.\" :\n                `Error fetching trending data: ${error.message}`;\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the trending cryptocurrencies?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the trending cryptocurrencies for you.\",\n                    action: \"GET_TRENDING\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the trending cryptocurrencies:\\n1. Bitcoin (BTC) - Rank #1\\n2. Ethereum (ETH) - Rank #2\\n{{dynamic}}\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me what's hot in crypto right now\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the current trending cryptocurrencies.\",\n                    action: \"GET_TRENDING\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the trending cryptocurrencies:\\n{{dynamic}}\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;","export const getTrendingTemplate = `\nExtract the following parameters for trending data:\n- **include_nfts** (boolean): Whether to include NFTs in the response (default: true)\n- **include_categories** (boolean): Whether to include categories in the response (default: true)\n\nProvide the values in the following JSON format:\n\n\\`\\`\\`json\n{\n    \"include_nfts\": true,\n    \"include_categories\": true\n}\n\\`\\`\\`\n\nExample request: \"What's trending in crypto?\"\nExample response:\n\\`\\`\\`json\n{\n    \"include_nfts\": true,\n    \"include_categories\": true\n}\n\\`\\`\\`\n\nExample request: \"Show me trending coins only\"\nExample response:\n\\`\\`\\`json\n{\n    \"include_nfts\": false,\n    \"include_categories\": false\n}\n\\`\\`\\`\n\nHere are the recent user messages for context:\n{{recentMessages}}\n\nBased on the conversation above, if the request is for trending market data, extract the appropriate parameters and respond with a JSON object. If the request is not related to trending data, respond with null.`;","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getTrendingPoolsTemplate } from \"../templates/trendingPools\";\n\ninterface TrendingPool {\n    id: string;\n    type: string;\n    attributes: {\n        name: string;\n        market_cap_usd: string;\n        fdv_usd: string;\n        reserve_in_usd: string;\n        pool_created_at: string;\n    };\n}\n\ninterface TrendingPoolsResponse {\n    data: TrendingPool[];\n}\n\nexport const GetTrendingPoolsSchema = z.object({\n    limit: z.number().min(1).max(100).default(10),\n});\n\nexport type GetTrendingPoolsContent = z.infer<typeof GetTrendingPoolsSchema> &\n    Content;\n\nexport const isGetTrendingPoolsContent = (\n    obj: unknown,\n): obj is GetTrendingPoolsContent => {\n    return GetTrendingPoolsSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_TRENDING_POOLS\",\n    similes: [\"TRENDING_POOLS\", \"HOT_POOLS\", \"POPULAR_POOLS\", \"TOP_POOLS\"],\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description: \"Get list of trending pools from CoinGecko's onchain data\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback,\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_TRENDING_POOLS handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            elizaLogger.log(\"Composing trending pools context...\");\n            const trendingContext = composeContext({\n                state: currentState,\n                template: getTrendingPoolsTemplate,\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: trendingContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetTrendingPoolsSchema,\n            });\n\n            if (!isGetTrendingPoolsContent(result.object)) {\n                elizaLogger.error(\"Invalid trending pools request format\");\n                return false;\n            }\n\n            // Fetch trending pools data from CoinGecko\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\"Fetching trending pools data...\");\n\n            const response = await axios.get<TrendingPoolsResponse>(\n                `${baseUrl}/onchain/networks/trending_pools?include=base_token,dex`,\n                {\n                    headers: {\n                        [headerKey]: apiKey,\n                    },\n                },\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            const formattedData = response.data.data.map((pool) => ({\n                name: pool.attributes.name,\n                marketCap: Number(\n                    pool.attributes.market_cap_usd,\n                ).toLocaleString(\"en-US\", {\n                    style: \"currency\",\n                    currency: \"USD\",\n                }),\n                fdv: Number(pool.attributes.fdv_usd).toLocaleString(\"en-US\", {\n                    style: \"currency\",\n                    currency: \"USD\",\n                }),\n                reserveUSD: Number(\n                    pool.attributes.reserve_in_usd,\n                ).toLocaleString(\"en-US\", {\n                    style: \"currency\",\n                    currency: \"USD\",\n                }),\n                createdAt: new Date(\n                    pool.attributes.pool_created_at,\n                ).toLocaleDateString(),\n            }));\n\n            const responseText = [\n                \"Trending Pools Overview:\",\n                \"\",\n                ...formattedData.map((pool, index) =>\n                    [\n                        `${index + 1}. ${pool.name}`,\n                        `   Market Cap: ${pool.marketCap}`,\n                        `   FDV: ${pool.fdv}`,\n                        `   Reserve: ${pool.reserveUSD}`,\n                        `   Created: ${pool.createdAt}`,\n                        \"\",\n                    ].join(\"\\n\"),\n                ),\n            ].join(\"\\n\");\n\n            elizaLogger.success(\"Trending pools data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        trendingPools: formattedData,\n                        timestamp: new Date().toISOString(),\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_TRENDING_POOLS handler:\", error);\n\n            const errorMessage =\n                error.response?.status === 429\n                    ? \"Rate limit exceeded. Please try again later.\"\n                    : `Error fetching trending pools data: ${error.message}`;\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me trending liquidity pools\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the trending liquidity pools for you.\",\n                    action: \"GET_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the trending liquidity pools:\\n1. MELANIA / USDC\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\\n2. TRUMP / USDC\\n   Market Cap: $8,844,297,825\\n   FDV: $43,874,068,484\\n   Reserve: $718,413,745\\n   Created: 1/17/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the top hottest dex pools?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the top hottest DEX pools for you.\",\n                    action: \"GET_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the top 5 hottest DEX pools:\\n1. TRUMP / USDC\\n   Market Cap: $8,844,297,825\\n   FDV: $43,874,068,484\\n   Reserve: $718,413,745\\n   Created: 1/17/2025\\n2. MELANIA / USDC\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List all trading pools with highest volume\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll get all the trending trading pools for you.\",\n                    action: \"GET_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are all trending trading pools:\\n1. MELANIA / USDC\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\\n2. TRUMP / USDC\\n   Market Cap: $8,844,297,825\\n   FDV: $43,874,068,484\\n   Reserve: $718,413,745\\n   Created: 1/17/2025\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getTrendingPoolsTemplate = `Determine if this is a trending pools request. If it is one of the specified situations, perform the corresponding action:\n\nSituation 1: \"Get all trending pools\"\n- Message contains: phrases like \"all trending pools\", \"show all pools\", \"list all pools\"\n- Example: \"Show me all trending pools\" or \"List all pools\"\n- Action: Return with limit=100\n\nSituation 2: \"Get specific number of pools\"\n- Message contains: number followed by \"pools\" or \"top\" followed by number and \"pools\"\n- Example: \"Show top 5 pools\" or \"Get me 20 trending pools\"\n- Action: Return with limit=specified number\n\nSituation 3: \"Default trending pools request\"\n- Message contains: general phrases like \"trending pools\", \"hot pools\", \"popular pools\"\n- Example: \"What are the trending pools?\" or \"Show me hot pools\"\n- Action: Return with limit=10\n\nFor all situations, respond with a JSON object in the format:\n\\`\\`\\`json\n{\n    \"limit\": number\n}\n\\`\\`\\`\n\nPrevious conversation for context:\n{{conversation}}\n\nYou are replying to: {{message}}\n`;","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getNewCoinsTemplate } from \"../templates/newCoins\";\n\ninterface NewCoin {\n    id: string;\n    symbol: string;\n    name: string;\n    activated_at: number;\n}\n\ninterface NewCoinsResponse extends Array<NewCoin> {}\n\nexport const GetNewCoinsSchema = z.object({\n    limit: z.number().min(1).max(50).default(10)\n});\n\nexport type GetNewCoinsContent = z.infer<typeof GetNewCoinsSchema> & Content;\n\nexport const isGetNewCoinsContent = (obj: unknown): obj is GetNewCoinsContent => {\n    return GetNewCoinsSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_NEW_COINS\",\n    similes: [\n        \"NEW_COINS\",\n        \"RECENTLY_ADDED\",\n        \"NEW_LISTINGS\",\n        \"LATEST_COINS\",\n    ],\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description: \"Get list of recently added coins from CoinGecko\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_NEW_COINS handler...\");\n\n        // Initialize or update state\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n\n        try {\n            elizaLogger.log(\"Composing new coins context...\");\n            const newCoinsContext = composeContext({\n                state: currentState,\n                template: getNewCoinsTemplate,\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: newCoinsContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetNewCoinsSchema\n            });\n\n            if (!isGetNewCoinsContent(result.object)) {\n                elizaLogger.error(\"Invalid new coins request format\");\n                return false;\n            }\n\n            // Fetch new coins data from CoinGecko\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\"Fetching new coins data...\");\n\n            const response = await axios.get<NewCoinsResponse>(\n                `${baseUrl}/coins/list/new`,\n                {\n                    headers: {\n                        [headerKey]: apiKey\n                    }\n                }\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            const formattedData = response.data\n                .slice(0, result.object.limit)\n                .map(coin => ({\n                    name: coin.name,\n                    symbol: coin.symbol.toUpperCase(),\n                    activatedAt: new Date(coin.activated_at * 1000).toLocaleString('en-US', {\n                        year: 'numeric',\n                        month: 'long',\n                        day: 'numeric',\n                        hour: '2-digit',\n                        minute: '2-digit'\n                    })\n                }));\n\n            const responseText = [\n                'Recently Added Coins:',\n                '',\n                ...formattedData.map((coin, index) =>\n                    `${index + 1}. ${coin.name} (${coin.symbol})\\n   Listed: ${coin.activatedAt}`\n                )\n            ].join('\\n');\n\n            elizaLogger.success(\"New coins data retrieved successfully!\");\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        newCoins: formattedData,\n                        timestamp: new Date().toISOString()\n                    }\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_NEW_COINS handler:\", error);\n\n            const errorMessage = error.response?.status === 429 ?\n                \"Rate limit exceeded. Please try again later.\" :\n                `Error fetching new coins data: ${error.message}`;\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the newest coins listed?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the recently added coins for you.\",\n                    action: \"GET_NEW_COINS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the recently added coins:\\n1. Verb Ai (VERB)\\n   Listed: January 20, 2025, 12:31 PM\\n{{dynamic}}\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;","export const getNewCoinsTemplate = `Determine if this is a new coins request. If it is one of the specified situations, perform the corresponding action:\n\nSituation 1: \"Get all new coins\"\n- Message contains: phrases like \"all new coins\", \"all recent listings\", \"all latest coins\"\n- Example: \"Show me all new coin listings\" or \"List all recently added coins\"\n- Action: Return with limit=50\n\nSituation 2: \"Get specific number of new coins\"\n- Message contains: number followed by \"new coins\" or \"latest\" followed by number and \"coins\"\n- Example: \"Show me 5 new coins\" or \"Get the latest 20 coins\"\n- Action: Return with limit=specified number\n\nSituation 3: \"Default new coins request\"\n- Message contains: general phrases like \"new coins\", \"recent listings\", \"latest coins\"\n- Example: \"What are the newest coins?\" or \"Show me recent listings\"\n- Action: Return with limit=10\n\nFor all situations, respond with a JSON object in the format:\n\\`\\`\\`json\n{\n    \"limit\": number\n}\n\\`\\`\\`\n\nPrevious conversation for context:\n{{conversation}}\n\nYou are replying to: {{message}}\n`;","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getNetworkTrendingPoolsTemplate } from \"../templates/networkTrendingPools\";\nimport { getNetworksData } from \"../providers/networkProvider\";\n\ninterface TrendingPool {\n    id: string;\n    type: string;\n    attributes: {\n        name: string;\n        market_cap_usd: string;\n        fdv_usd: string;\n        reserve_in_usd: string;\n        pool_created_at: string;\n    };\n}\n\ninterface TrendingPoolsResponse {\n    data: TrendingPool[];\n}\n\nexport const GetNetworkTrendingPoolsSchema = z.object({\n    networkId: z.string(),\n    limit: z.number().min(1).max(100).default(10),\n});\n\nexport type GetNetworkTrendingPoolsContent = z.infer<\n    typeof GetNetworkTrendingPoolsSchema\n> &\n    Content;\n\nexport const isGetNetworkTrendingPoolsContent = (\n    obj: unknown\n): obj is GetNetworkTrendingPoolsContent => {\n    return GetNetworkTrendingPoolsSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_NETWORK_TRENDING_POOLS\",\n    similes: [\n        \"NETWORK_TRENDING_POOLS\",\n        \"CHAIN_HOT_POOLS\",\n        \"BLOCKCHAIN_POPULAR_POOLS\",\n    ],\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description:\n        \"Get list of trending pools for a specific network from CoinGecko's onchain data\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\n            \"Starting CoinGecko GET_NETWORK_TRENDING_POOLS handler...\"\n        );\n\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        try {\n            elizaLogger.log(\"Composing network trending pools context...\");\n            const trendingContext = composeContext({\n                state: currentState,\n                template: getNetworkTrendingPoolsTemplate,\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: trendingContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetNetworkTrendingPoolsSchema,\n            });\n\n            if (!isGetNetworkTrendingPoolsContent(result.object)) {\n                elizaLogger.error(\n                    \"Invalid network trending pools request format\"\n                );\n                return false;\n            }\n\n            // Fetch networks data first\n            const networks = await getNetworksData(runtime);\n\n            // Find the matching network\n            const network = networks.find((n) => {\n                const searchTerm = (\n                    result.object as { networkId: string }\n                ).networkId.toLowerCase();\n                return (\n                    n.id.toLowerCase() === searchTerm ||\n                    n.attributes.name.toLowerCase().includes(searchTerm) ||\n                    n.attributes.coingecko_asset_platform_id.toLowerCase() ===\n                        searchTerm\n                );\n            });\n\n            if (!network) {\n                throw new Error(\n                    `Network ${result.object.networkId} not found in available networks`\n                );\n            }\n\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\n                `Fetching trending pools data for network: ${network.id}`\n            );\n\n            const response = await axios.get<TrendingPoolsResponse>(\n                `${baseUrl}/onchain/networks/${network.id}/trending_pools?include=base_token,dex`,\n                {\n                    headers: {\n                        [headerKey]: apiKey,\n                    },\n                }\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            const formattedData = response.data.data\n                .slice(0, result.object.limit)\n                .map((pool) => ({\n                    name: pool.attributes.name,\n                    marketCap: Number(\n                        pool.attributes.market_cap_usd\n                    ).toLocaleString(\"en-US\", {\n                        style: \"currency\",\n                        currency: \"USD\",\n                    }),\n                    fdv: Number(pool.attributes.fdv_usd).toLocaleString(\n                        \"en-US\",\n                        {\n                            style: \"currency\",\n                            currency: \"USD\",\n                        }\n                    ),\n                    reserveUSD: Number(\n                        pool.attributes.reserve_in_usd\n                    ).toLocaleString(\"en-US\", {\n                        style: \"currency\",\n                        currency: \"USD\",\n                    }),\n                    createdAt: new Date(\n                        pool.attributes.pool_created_at\n                    ).toLocaleDateString(),\n                }));\n\n            const responseText = [\n                `Trending Pools Overview for ${network.attributes.name}:`,\n                \"\",\n                ...formattedData.map((pool, index) =>\n                    [\n                        `${index + 1}. ${pool.name}`,\n                        `   Market Cap: ${pool.marketCap}`,\n                        `   FDV: ${pool.fdv}`,\n                        `   Reserve: ${pool.reserveUSD}`,\n                        `   Created: ${pool.createdAt}`,\n                        \"\",\n                    ].join(\"\\n\")\n                ),\n            ].join(\"\\n\");\n\n            elizaLogger.success(\n                \"Network trending pools data retrieved successfully!\"\n            );\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        networkId: network.id,\n                        networkName: network.attributes.name,\n                        trendingPools: formattedData,\n                        timestamp: new Date().toISOString(),\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\n                \"Error in GET_NETWORK_TRENDING_POOLS handler:\",\n                error\n            );\n\n            const errorMessage =\n                error.response?.status === 429\n                    ? \"Rate limit exceeded. Please try again later.\"\n                    : `Error fetching trending pools data: ${error.message}`;\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me trending liquidity pools on Solana\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the trending Solana liquidity pools for you.\",\n                    action: \"GET_NETWORK_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the trending pools on SOLANA:\\n1. MELANIA / USDC\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\\n2. TRUMP / USDC\\n   Market Cap: $8,844,297,825\\n   FDV: $43,874,068,484\\n   Reserve: $718,413,745\\n   Created: 1/17/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the top 5 hottest pools on Ethereum?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the top 5 hottest pools on Ethereum for you.\",\n                    action: \"GET_NETWORK_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the top 5 trending pools on ETHEREUM:\\n1. PEPE / WETH\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List all BSC pools with highest volume\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll get all the trending pools on BSC for you.\",\n                    action: \"GET_NETWORK_TRENDING_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are all trending pools on BSC:\\n1. CAKE / WBNB\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getNetworkTrendingPoolsTemplate = `Determine if this is a network-specific trending pools request. If it is one of the specified situations, extract the network ID and limit:\n\nSituation 1: \"Get network trending pools\"\n- Message contains: network name (e.g., \"solana\", \"ethereum\", \"bsc\") AND phrases about pools\n- Example: \"Show trending pools on Solana\" or \"What are the hot pools on ETH?\"\n- Action: Extract network ID and use default limit\n\nSituation 2: \"Get specific number of network pools\"\n- Message contains: number AND network name AND pools reference\n- Example: \"Show top 5 pools on BSC\" or \"Get 20 trending pools on Ethereum\"\n- Action: Extract network ID and specific limit\n\nSituation 3: \"Get all network pools\"\n- Message contains: \"all\" AND network name AND pools reference\n- Example: \"Show all trending pools on Polygon\" or \"List all hot pools on Avalanche\"\n- Action: Extract network ID and set maximum limit\n\nNetwork ID mappings:\n- \"solana\", \"sol\" => \"solana\"\n- \"ethereum\", \"eth\" => \"eth\"\n- \"binance smart chain\", \"bsc\", \"bnb chain\" => \"bsc\"\n- \"polygon\", \"matic\" => \"polygon_pos\"\n- \"avalanche\", \"avax\" => \"avax\"\n\nFor all situations, respond with a JSON object in the format:\n\\`\\`\\`json\n{\n    \"networkId\": string,\n    \"limit\": number\n}\n\\`\\`\\`\n\nPrevious conversation for context:\n{{conversation}}\n\nYou are replying to: {{message}}\n`;\n","import {\n    type IAgentRuntime,\n    type Memory,\n    type Provider,\n    type State,\n    elizaLogger,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\n\ninterface NetworkAttributes {\n    name: string;\n    coingecko_asset_platform_id: string;\n}\n\ninterface NetworkItem {\n    id: string;\n    type: string;\n    attributes: NetworkAttributes;\n}\n\ninterface NetworksResponse {\n    data: NetworkItem[];\n}\n\nconst CACHE_KEY = \"coingecko:networks\";\nconst CACHE_TTL = 30 * 60; // 30 minutes\nconst MAX_RETRIES = 3;\n\nasync function fetchNetworks(runtime: IAgentRuntime): Promise<NetworkItem[]> {\n    const config = await validateCoingeckoConfig(runtime);\n    const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n    const response = await axios.get<NetworksResponse>(\n        `${baseUrl}/onchain/networks`,\n        {\n            headers: {\n                accept: \"application/json\",\n                [headerKey]: apiKey,\n            },\n            timeout: 5000, // 5 second timeout\n        }\n    );\n\n    if (!response.data?.data?.length) {\n        throw new Error(\"Invalid networks data received\");\n    }\n\n    return response.data.data;\n}\n\nasync function fetchWithRetry(runtime: IAgentRuntime): Promise<NetworkItem[]> {\n    let lastError: Error | null = null;\n\n    for (let i = 0; i < MAX_RETRIES; i++) {\n        try {\n            return await fetchNetworks(runtime);\n        } catch (error) {\n            lastError = error;\n            elizaLogger.error(`Networks fetch attempt ${i + 1} failed:`, error);\n            await new Promise((resolve) => setTimeout(resolve, 1000 * (i + 1)));\n        }\n    }\n\n    throw (\n        lastError ||\n        new Error(\"Failed to fetch networks after multiple attempts\")\n    );\n}\n\nasync function getNetworks(runtime: IAgentRuntime): Promise<NetworkItem[]> {\n    try {\n        // Try to get from cache first\n        const cached = await runtime.cacheManager.get<NetworkItem[]>(CACHE_KEY);\n        if (cached) {\n            return cached;\n        }\n\n        // Fetch fresh data\n        const networks = await fetchWithRetry(runtime);\n\n        // Cache the result\n        await runtime.cacheManager.set(CACHE_KEY, networks, {\n            expires: CACHE_TTL,\n        });\n\n        return networks;\n    } catch (error) {\n        elizaLogger.error(\"Error fetching networks:\", error);\n        throw error;\n    }\n}\n\nfunction formatNetworksContext(networks: NetworkItem[]): string {\n    const mainNetworks = [\"eth\", \"bsc\", \"polygon_pos\", \"avax\", \"solana\"];\n\n    const popular = networks\n        .filter((n) => mainNetworks.includes(n.id))\n        .map((n) => `${n.attributes.name} - ID: ${n.id}`);\n\n    return `\nAvailable blockchain networks:\n\nMajor networks:\n${popular.map((n) => `- ${n}`).join(\"\\n\")}\n\nTotal available networks: ${networks.length}\n\nYou can use these network IDs when querying network-specific data.\n`.trim();\n}\n\nexport const networksProvider: Provider = {\n    // eslint-disable-next-line\n    get: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state?: State\n    ): Promise<string> => {\n        try {\n            const networks = await getNetworks(runtime);\n            return formatNetworksContext(networks);\n        } catch (error) {\n            elizaLogger.error(\"Networks provider error:\", error);\n            return \"Blockchain networks list is temporarily unavailable. Please try again later.\";\n        }\n    },\n};\n\n// Helper function for actions to get raw networks data\nexport async function getNetworksData(\n    runtime: IAgentRuntime\n): Promise<NetworkItem[]> {\n    return getNetworks(runtime);\n}\n","import {\n    type ActionExample,\n    composeContext,\n    type Content,\n    elizaLogger,\n    generateObject,\n    type HandlerCallback,\n    type IAgentRuntime,\n    type Memory,\n    ModelClass,\n    type State,\n    type Action,\n} from \"@elizaos/core\";\nimport axios from \"axios\";\nimport { z } from \"zod\";\nimport { getApiConfig, validateCoingeckoConfig } from \"../environment\";\nimport { getNetworkNewPoolsTemplate } from \"../templates/networkNewPools\";\nimport { getNetworksData } from \"../providers/networkProvider\";\n\ninterface NewPool {\n    id: string;\n    type: string;\n    attributes: {\n        name: string;\n        market_cap_usd: string;\n        fdv_usd: string;\n        reserve_in_usd: string;\n        pool_created_at: string;\n    };\n}\n\ninterface NewPoolsResponse {\n    data: NewPool[];\n}\n\nexport const GetNetworkNewPoolsSchema = z.object({\n    networkId: z.string(),\n    limit: z.number().min(1).max(100).default(10),\n});\n\nexport type GetNetworkNewPoolsContent = z.infer<\n    typeof GetNetworkNewPoolsSchema\n> &\n    Content;\n\nexport const isGetNetworkNewPoolsContent = (\n    obj: unknown\n): obj is GetNetworkNewPoolsContent => {\n    return GetNetworkNewPoolsSchema.safeParse(obj).success;\n};\n\nexport default {\n    name: \"GET_NETWORK_NEW_POOLS\",\n    similes: [\n        \"NETWORK_NEW_POOLS\",\n        \"CHAIN_NEW_POOLS\",\n        \"NEW_POOLS_BY_NETWORK\",\n        \"RECENT_POOLS\",\n        \"LATEST_POOLS\",\n    ],\n    validate: async (runtime: IAgentRuntime, _message: Memory) => {\n        await validateCoingeckoConfig(runtime);\n        return true;\n    },\n    description:\n        \"Get list of newly created pools for a specific network from CoinGecko's onchain data\",\n    handler: async (\n        runtime: IAgentRuntime,\n        message: Memory,\n        state: State,\n        _options: { [key: string]: unknown },\n        callback?: HandlerCallback\n    ): Promise<boolean> => {\n        elizaLogger.log(\"Starting CoinGecko GET_NETWORK_NEW_POOLS handler...\");\n\n        let currentState = state;\n        if (!currentState) {\n            currentState = (await runtime.composeState(message)) as State;\n        } else {\n            currentState = await runtime.updateRecentMessageState(currentState);\n        }\n\n        try {\n            elizaLogger.log(\"Composing network new pools context...\");\n            const newPoolsContext = composeContext({\n                state: currentState,\n                template: getNetworkNewPoolsTemplate,\n            });\n\n            const result = await generateObject({\n                runtime,\n                context: newPoolsContext,\n                modelClass: ModelClass.LARGE,\n                schema: GetNetworkNewPoolsSchema,\n            });\n\n            if (!isGetNetworkNewPoolsContent(result.object)) {\n                elizaLogger.error(\"Invalid network new pools request format\");\n                return false;\n            }\n\n            // Fetch networks data first\n            const networks = await getNetworksData(runtime);\n\n            // Fetch networks data first\n            const networksResponse = await getNetworksData(runtime);\n\n            // Find the matching network from the data array\n            const network = networksResponse.find((n) => {\n                const searchTerm = (\n                    result.object as { networkId: string }\n                ).networkId.toLowerCase();\n                return (\n                    n.id.toLowerCase() === searchTerm ||\n                    n.attributes.name.toLowerCase().includes(searchTerm) ||\n                    n.attributes.coingecko_asset_platform_id.toLowerCase() ===\n                        searchTerm\n                );\n            });\n\n            if (!network) {\n                throw new Error(\n                    `Network ${result.object.networkId} not found in available networks`\n                );\n            }\n\n            const config = await validateCoingeckoConfig(runtime);\n            const { baseUrl, apiKey, headerKey } = getApiConfig(config);\n\n            elizaLogger.log(\n                `Fetching new pools data for network: ${network.id}`\n            );\n\n            const response = await axios.get<NewPoolsResponse>(\n                `${baseUrl}/onchain/networks/${network.id}/new_pools?include=base_token,dex`,\n                {\n                    headers: {\n                        [headerKey]: apiKey,\n                    },\n                }\n            );\n\n            if (!response.data) {\n                throw new Error(\"No data received from CoinGecko API\");\n            }\n\n            const formattedData = response.data.data\n                .slice(0, result.object.limit)\n                .map((pool) => ({\n                    name: pool.attributes.name,\n                    marketCap: Number(\n                        pool.attributes.market_cap_usd\n                    ).toLocaleString(\"en-US\", {\n                        style: \"currency\",\n                        currency: \"USD\",\n                    }),\n                    fdv: Number(pool.attributes.fdv_usd).toLocaleString(\n                        \"en-US\",\n                        {\n                            style: \"currency\",\n                            currency: \"USD\",\n                        }\n                    ),\n                    reserveUSD: Number(\n                        pool.attributes.reserve_in_usd\n                    ).toLocaleString(\"en-US\", {\n                        style: \"currency\",\n                        currency: \"USD\",\n                    }),\n                    createdAt: new Date(\n                        pool.attributes.pool_created_at\n                    ).toLocaleDateString(),\n                }));\n\n            const responseText = [\n                `New Pools Overview for ${network.attributes.name}:`,\n                \"\",\n                ...formattedData.map((pool, index) =>\n                    [\n                        `${index + 1}. ${pool.name}`,\n                        `   Market Cap: ${pool.marketCap}`,\n                        `   FDV: ${pool.fdv}`,\n                        `   Reserve: ${pool.reserveUSD}`,\n                        `   Created: ${pool.createdAt}`,\n                        \"\",\n                    ].join(\"\\n\")\n                ),\n            ].join(\"\\n\");\n\n            elizaLogger.success(\n                \"Network new pools data retrieved successfully!\"\n            );\n\n            if (callback) {\n                callback({\n                    text: responseText,\n                    content: {\n                        networkId: network.id,\n                        networkName: network.attributes.name,\n                        newPools: formattedData,\n                        timestamp: new Date().toISOString(),\n                    },\n                });\n            }\n\n            return true;\n        } catch (error) {\n            elizaLogger.error(\"Error in GET_NETWORK_NEW_POOLS handler:\", error);\n\n            const errorMessage =\n                error.response?.status === 429\n                    ? \"Rate limit exceeded. Please try again later.\"\n                    : `Error fetching new pools data: ${error.message}`;\n\n            if (callback) {\n                callback({\n                    text: errorMessage,\n                    content: {\n                        error: error.message,\n                        statusCode: error.response?.status,\n                    },\n                });\n            }\n            return false;\n        }\n    },\n\n    examples: [\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"Show me new liquidity pools on Ethereum\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll check the new Ethereum liquidity pools for you.\",\n                    action: \"GET_NETWORK_NEW_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the new pools on ETHEREUM:\\n1. PEPE / WETH\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\\n2. SUSHI / WETH\\n   Market Cap: $8,844,297,825\\n   FDV: $43,874,068,484\\n   Reserve: $718,413,745\\n   Created: 1/17/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"What are the 5 latest pools on BSC?\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll fetch the 5 latest pools on BSC for you.\",\n                    action: \"GET_NETWORK_NEW_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are the 5 newest pools on BSC:\\n1. CAKE / WBNB\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\",\n                },\n            },\n        ],\n        [\n            {\n                user: \"{{user1}}\",\n                content: {\n                    text: \"List all recent pools on Polygon\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"I'll get all the recently added pools on Polygon for you.\",\n                    action: \"GET_NETWORK_NEW_POOLS\",\n                },\n            },\n            {\n                user: \"{{agent}}\",\n                content: {\n                    text: \"Here are all new pools on POLYGON:\\n1. MATIC / USDC\\n   Market Cap: $954,636,707\\n   FDV: $6,402,478,508\\n   Reserve: $363,641,037\\n   Created: 1/19/2025\",\n                },\n            },\n        ],\n    ] as ActionExample[][],\n} as Action;\n","export const getNetworkNewPoolsTemplate = `Determine if this is a network-specific new pools request. If it is one of the specified situations, extract the network ID and limit:\n\nSituation 1: \"Get network new pools\"\n- Message contains: network name AND phrases about new/recent/latest pools\n- Example: \"Show new pools on Ethereum\" or \"What are the latest pools on BSC?\"\n- Action: Extract network ID and use default limit\n\nSituation 2: \"Get specific number of new pools\"\n- Message contains: number AND network name AND new/recent/latest pools reference\n- Example: \"Show 5 newest pools on Polygon\" or \"Get 20 latest pools on Avalanche\"\n- Action: Extract network ID and specific limit\n\nSituation 3: \"Get all new pools\"\n- Message contains: \"all\" AND network name AND new/recent/latest pools reference\n- Example: \"Show all new pools on BSC\" or \"List all recent pools on Ethereum\"\n- Action: Extract network ID and set maximum limit\n\nNetwork ID mappings:\n- \"solana\", \"sol\" => \"solana\"\n- \"ethereum\", \"eth\" => \"eth\"\n- \"binance smart chain\", \"bsc\", \"bnb chain\" => \"bsc\"\n- \"polygon\", \"matic\" => \"polygon_pos\"\n- \"avalanche\", \"avax\" => \"avax\"\n\nFor all situations, respond with a JSON object in the format:\n\\`\\`\\`json\n{\n    \"networkId\": string,\n    \"limit\": number\n}\n\\`\\`\\`\n\nPrevious conversation for context:\n{{conversation}}\n\nYou are replying to: {{message}}\n`;\n","import getMarkets from \"./actions/getMarkets\";\nimport getPrice from \"./actions/getPrice\";\nimport getPricePerAddress from \"./actions/getPricePerAddress\";\nimport getTopGainersLosers from \"./actions/getTopGainersLosers\";\nimport getTrending from \"./actions/getTrending\";\nimport getTrendingPools from \"./actions/getTrendingPools\";\nimport getNewlyListed from \"./actions/getNewlyListed\";\nimport getNetworkTrendingPools from \"./actions/getNetworkTrendingPools\";\nimport getNetworkNewPools from \"./actions/getNetworkNewPools\";\nimport { categoriesProvider } from \"./providers/categoriesProvider\";\nimport { coinsProvider } from \"./providers/coinsProvider\";\nimport { networksProvider } from \"./providers/networkProvider\";\n\nexport const coingeckoPlugin = {\n    name: \"coingecko\",\n    description: \"CoinGecko Plugin for Eliza\",\n    actions: [\n        getPrice,\n        getPricePerAddress,\n        getTrending,\n        getTrendingPools,\n        getMarkets,\n        getTopGainersLosers,\n        getNewlyListed,\n        getNetworkTrendingPools,\n        getNetworkNewPools,\n    ],\n    evaluators: [],\n    providers: [categoriesProvider, coinsProvider, networksProvider],\n};\n\nexport default coingeckoPlugin;\n"],"mappings":";AAAA;AAAA,EAEI;AAAA,EAEA,eAAAA;AAAA,EACA;AAAA,EAIA;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACblB,SAAS,SAAS;AAElB,IAAM,wBAAwB,EAAE,OAAO;AAAA,EACnC,mBAAmB,EAAE,OAAO,EAAE,SAAS;AAAA,EACvC,uBAAuB,EAAE,OAAO,EAAE,SAAS;AAC/C,CAAC,EAAE,OAAO,UAAQ,KAAK,qBAAqB,KAAK,uBAAuB;AAAA,EACpE,SAAS;AACb,CAAC;AAID,eAAsB,wBAAwB,SAAkD;AAC5F,QAAM,SAAS;AAAA,IACX,mBAAmB,QAAQ,WAAW,mBAAmB;AAAA,IACzD,uBAAuB,QAAQ,WAAW,uBAAuB;AAAA,EACrE;AAEA,SAAO,sBAAsB,MAAM,MAAM;AAC7C;AAEO,SAAS,aAAa,QAAyB;AAClD,QAAM,QAAQ,CAAC,CAAC,OAAO;AACvB,SAAO;AAAA,IACH,SAAS,QAAQ,yCAAyC;AAAA,IAC1D,QAAQ,QAAQ,OAAO,wBAAwB,OAAO;AAAA,IACtD,WAAW,QAAQ,qBAAqB;AAAA,EAC5C;AACJ;;;AC5BA,SAAqE,mBAAmB;AACxF,OAAO,WAAW;AAQlB,IAAM,YAAY;AAClB,IAAM,YAAY,IAAI;AACtB,IAAM,cAAc;AAEpB,eAAe,gBAAgB,SAAiD;AAbhF;AAcI,QAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,QAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,QAAM,WAAW,MAAM,MAAM;AAAA,IACzB,GAAG,OAAO;AAAA,IACV;AAAA,MACI,SAAS;AAAA,QACL,UAAU;AAAA,QACV,CAAC,SAAS,GAAG;AAAA,MACjB;AAAA,MACA,SAAS;AAAA;AAAA,IACb;AAAA,EACJ;AAEA,MAAI,GAAC,cAAS,SAAT,mBAAe,SAAQ;AACxB,UAAM,IAAI,MAAM,kCAAkC;AAAA,EACtD;AAEA,SAAO,SAAS;AACpB;AAEA,eAAe,eAAe,SAAiD;AAC3E,MAAI,YAA0B;AAE9B,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK;AAClC,QAAI;AACA,aAAO,MAAM,gBAAgB,OAAO;AAAA,IACxC,SAAS,OAAO;AACZ,kBAAY;AACZ,kBAAY,MAAM,4BAA4B,IAAI,CAAC,YAAY,KAAK;AACpE,YAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAQ,IAAI,EAAE,CAAC;AAAA,IACpE;AAAA,EACJ;AAEA,QAAM,aAAa,IAAI,MAAM,oDAAoD;AACrF;AAEA,eAAe,cAAc,SAAiD;AAC1E,MAAI;AAEA,UAAM,SAAS,MAAM,QAAQ,aAAa,IAAoB,SAAS;AACvE,QAAI,QAAQ;AACR,aAAO;AAAA,IACX;AAGA,UAAM,aAAa,MAAM,eAAe,OAAO;AAG/C,UAAM,QAAQ,aAAa,IAAI,WAAW,YAAY,EAAE,SAAS,UAAU,CAAC;AAE5E,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,gBAAY,MAAM,8BAA8B,KAAK;AACrD,UAAM;AAAA,EACV;AACJ;AAEA,SAAS,wBAAwB,YAAoC;AACjE,QAAM,oBAAoB;AAAA,IACtB;AAAA,IAAW;AAAA,IAAQ;AAAA,IAAQ;AAAA,IAC3B;AAAA,IAA2B;AAAA,IAAU;AAAA,EACzC;AAEA,QAAM,UAAU,WACX,OAAO,OAAK,kBAAkB,SAAS,EAAE,WAAW,CAAC,EACrD,IAAI,OAAK,GAAG,EAAE,IAAI,KAAK,EAAE,WAAW,GAAG;AAE5C,SAAO;AAAA;AAAA;AAAA;AAAA,EAIT,QAAQ,IAAI,OAAK,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,8BAET,WAAW,MAAM;AAAA;AAAA;AAAA,EAG7C,KAAK;AACP;AAEO,IAAM,qBAA+B;AAAA;AAAA,EAExC,KAAK,OAAO,SAAwB,SAAiB,UAAmC;AACpF,QAAI;AACA,YAAM,aAAa,MAAM,cAAc,OAAO;AAC9C,aAAO,wBAAwB,UAAU;AAAA,IAC7C,SAAS,OAAO;AACZ,kBAAY,MAAM,8BAA8B,KAAK;AACrD,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAGA,eAAsB,kBAAkB,SAAiD;AACrF,SAAO,cAAc,OAAO;AAChC;;;AC9GO,IAAM,qBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AHwB3B,SAAS,eAAe,UAA8B,YAAgD;AACzG,MAAI,CAAC,SAAU,QAAO;AAEtB,QAAM,kBAAkB,SAAS,YAAY,EAAE,KAAK;AAGpD,QAAM,aAAa,WAAW,KAAK,OAAK,EAAE,gBAAgB,eAAe;AACzE,MAAI,YAAY;AACZ,WAAO,WAAW;AAAA,EACtB;AAGA,QAAM,YAAY,WAAW;AAAA,IAAK,OAC9B,EAAE,KAAK,YAAY,MAAM,mBACzB,EAAE,KAAK,YAAY,EAAE,QAAQ,eAAe,GAAG,MAAM;AAAA,EACzD;AACA,MAAI,WAAW;AACX,WAAO,UAAU;AAAA,EACrB;AAGA,QAAM,eAAe,WAAW;AAAA,IAAK,OACjC,EAAE,KAAK,YAAY,EAAE,SAAS,eAAe,KAC7C,EAAE,YAAY,SAAS,eAAe;AAAA,EAC1C;AACA,MAAI,cAAc;AACd,WAAO,aAAa;AAAA,EACxB;AAEA,SAAO;AACX;AAkCO,IAAM,mBAAmBC,GAAE,OAAO;AAAA,EACrC,aAAaA,GAAE,OAAO,EAAE,QAAQ,KAAK;AAAA,EACrC,UAAUA,GAAE,OAAO,EAAE,SAAS;AAAA,EAC9B,OAAOA,GAAE,KAAK,CAAC,mBAAmB,kBAAkB,eAAe,YAAY,CAAC,EAAE,QAAQ,iBAAiB;AAAA,EAC3G,UAAUA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG,EAAE,QAAQ,EAAE;AAAA,EAC/C,MAAMA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,QAAQ,CAAC;AAAA,EACjC,WAAWA,GAAE,QAAQ,EAAE,QAAQ,KAAK;AACxC,CAAC;AAIM,IAAM,sBAAsB,CAAC,QAA2C;AAC3E,SAAO,iBAAiB,UAAU,GAAG,EAAE;AAC3C;AAEA,IAAO,qBAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AA9H3B;AA+HQ,IAAAC,aAAY,IAAI,2CAA2C;AAG3D,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAG1D,YAAM,aAAa,MAAM,kBAAkB,OAAO;AAGlD,YAAM,iBAAiB,eAAe;AAAA,QAClC,OAAO;AAAA,QACP,UAAU,mBAAmB;AAAA,UAAQ;AAAA,UACjC,WAAW,IAAI,OAAK,KAAK,EAAE,IAAI,SAAS,EAAE,WAAW,GAAG,EAAE,KAAK,IAAI;AAAA,QACvE;AAAA,MACJ,CAAC;AAED,YAAM,SAAS,MAAM,eAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAY,WAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,oBAAoB,OAAO,MAAM,GAAG;AACrC,QAAAA,aAAY,MAAM,qCAAqC;AACvD,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,OAAO;AACvB,MAAAA,aAAY,IAAI,0BAA0B,OAAO;AAGjD,UAAI,CAAC,SAAS;AACV,eAAO;AAAA,MACX;AAEA,YAAM,oBAAoB,eAAe,QAAQ,UAAU,UAAU;AACrE,UAAI,QAAQ,YAAY,CAAC,mBAAmB;AACxC,cAAM,IAAI,MAAM,qBAAqB,QAAQ,QAAQ,gDAAgD;AAAA,MACzG;AAEA,MAAAA,aAAY,IAAI,mCAAmC;AAAA,QAC/C,KAAK,GAAG,OAAO;AAAA,QACf,UAAU;AAAA,QACV,aAAa,QAAQ;AAAA,QACrB,OAAO,QAAQ;AAAA,QACf,UAAU,QAAQ;AAAA,QAClB,MAAM,QAAQ;AAAA,MAClB,CAAC;AAED,YAAM,WAAW,MAAMC,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,SAAS;AAAA,YACL,UAAU;AAAA,YACV,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,UACA,QAAQ;AAAA,YACJ,aAAa,QAAQ;AAAA,YACrB,UAAU;AAAA,YACV,OAAO,QAAQ;AAAA,YACf,UAAU,QAAQ;AAAA,YAClB,MAAM,QAAQ;AAAA,YACd,WAAW,QAAQ;AAAA,UACvB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,GAAC,cAAS,SAAT,mBAAe,SAAQ;AACxB,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAChE;AAEA,YAAM,gBAAgB,SAAS,KAAK,IAAI,WAAS;AAAA,QAC7C,MAAM,KAAK;AAAA,QACX,QAAQ,KAAK,OAAO,YAAY;AAAA,QAChC,eAAe,KAAK;AAAA,QACpB,cAAc,KAAK;AAAA,QACnB,gBAAgB,KAAK;AAAA,QACrB,0BAA0B,KAAK;AAAA,QAC/B,WAAW,KAAK;AAAA,QAChB,WAAW,KAAK;AAAA,QAChB,SAAS,KAAK;AAAA,QACd,QAAQ,KAAK;AAAA,QACb,mBAAmB,KAAK;AAAA,QACxB,aAAa,KAAK;AAAA,QAClB,WAAW,KAAK;AAAA,QAChB,aAAa,KAAK;AAAA,MACtB,EAAE;AAEF,YAAM,kBAAkB,QAAQ,WAC5B,KAAG,gBAAW,KAAK,OAAK,EAAE,gBAAgB,iBAAiB,MAAxD,mBAA2D,KAAK,kBAAiB,QAAQ,SAAS,YAAY,CAAC,MAAM;AAE5H,YAAM,eAAe;AAAA,QACjB,OAAO,cAAc,MAAM,IAAI,eAAe,uBAAuB,QAAQ,UAAU,iBAAiB,QAAQ,UAAU,eAAe,WAAW,YAAY;AAAA,QAChK,GAAG,cAAc;AAAA,UAAI,CAAC,MAAM,UACxB,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,QACnC,KAAK,aAAa,eAAe,CAAC,MACnC,KAAK,yBAAyB,QAAQ,CAAC,CAAC,eAChC,KAAK,YAAY,KAAK,QAAQ,CAAC,CAAC;AAAA,QAClD;AAAA,MACJ,EAAE,KAAK,IAAI;AAEX,MAAAD,aAAY,QAAQ,qCAAqC;AAEzD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,SAAS;AAAA,YACT,QAAQ;AAAA,cACJ,aAAa,QAAQ;AAAA,cACrB,UAAU,QAAQ;AAAA,cAClB,OAAO,QAAQ;AAAA,cACf,UAAU,QAAQ;AAAA,cAClB,MAAM,QAAQ;AAAA,YAClB;AAAA,YACA,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,iCAAiC,KAAK;AAExD,UAAI;AACJ,YAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAChC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB,OAAO;AACH,uBAAe,+BAA+B,MAAM,OAAO;AAAA,MAC/D;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,OAAO;AAAA,YACH,SAAS,MAAM;AAAA,YACf,aAAY,WAAM,aAAN,mBAAgB;AAAA,YAC5B,SAAQ,WAAM,WAAN,mBAAc;AAAA,YACtB,mBAAiB,WAAM,aAAN,mBAAgB,YAAW;AAAA,UAChD;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AIvTA;AAAA,EAEI,kBAAAE;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdlB,SAAqE,eAAAC,oBAAmB;AACxF,OAAOC,YAAW;AASlB,IAAMC,aAAY;AAClB,IAAMC,aAAY,IAAI;AACtB,IAAMC,eAAc;AAEpB,eAAe,WAAW,SAAwB,kBAAkB,OAA4B;AAdhG;AAeI,QAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,QAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,QAAM,WAAW,MAAMC,OAAM;AAAA,IACzB,GAAG,OAAO;AAAA,IACV;AAAA,MACI,QAAQ;AAAA,QACJ,kBAAkB;AAAA,MACtB;AAAA,MACA,SAAS;AAAA,QACL,UAAU;AAAA,QACV,CAAC,SAAS,GAAG;AAAA,MACjB;AAAA,MACA,SAAS;AAAA;AAAA,IACb;AAAA,EACJ;AAEA,MAAI,GAAC,cAAS,SAAT,mBAAe,SAAQ;AACxB,UAAM,IAAI,MAAM,6BAA6B;AAAA,EACjD;AAEA,SAAO,SAAS;AACpB;AAEA,eAAeC,gBAAe,SAAwB,kBAAkB,OAA4B;AAChG,MAAI,YAA0B;AAE9B,WAAS,IAAI,GAAG,IAAIF,cAAa,KAAK;AAClC,QAAI;AACA,aAAO,MAAM,WAAW,SAAS,eAAe;AAAA,IACpD,SAAS,OAAO;AACZ,kBAAY;AACZ,MAAAG,aAAY,MAAM,uBAAuB,IAAI,CAAC,YAAY,KAAK;AAC/D,YAAM,IAAI,QAAQ,aAAW,WAAW,SAAS,OAAQ,IAAI,EAAE,CAAC;AAAA,IACpE;AAAA,EACJ;AAEA,QAAM,aAAa,IAAI,MAAM,+CAA+C;AAChF;AAEA,eAAe,SAAS,SAAwB,kBAAkB,OAA4B;AAC1F,MAAI;AAEA,UAAM,SAAS,MAAM,QAAQ,aAAa,IAAgBL,UAAS;AACnE,QAAI,QAAQ;AACR,aAAO;AAAA,IACX;AAGA,UAAM,QAAQ,MAAMI,gBAAe,SAAS,eAAe;AAG3D,UAAM,QAAQ,aAAa,IAAIJ,YAAW,OAAO,EAAE,SAASC,WAAU,CAAC;AAEvE,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,IAAAI,aAAY,MAAM,yBAAyB,KAAK;AAChD,UAAM;AAAA,EACV;AACJ;AAEA,SAAS,mBAAmB,OAA2B;AACnD,QAAM,eAAe;AAAA,IACjB;AAAA,IAAW;AAAA,IAAY;AAAA,IAAe;AAAA,IACtC;AAAA,IAAW;AAAA,IAAU;AAAA,IAAY;AAAA,EACrC;AAEA,QAAM,UAAU,MACX,OAAO,OAAK,aAAa,SAAS,EAAE,EAAE,CAAC,EACvC,IAAI,OAAK,GAAG,EAAE,IAAI,KAAK,EAAE,OAAO,YAAY,CAAC,WAAW,EAAE,EAAE,EAAE;AAEnE,SAAO;AAAA;AAAA;AAAA;AAAA,EAIT,QAAQ,IAAI,OAAK,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,yBAEd,MAAM,MAAM;AAAA;AAAA;AAAA,EAGnC,KAAK;AACP;AAEO,IAAM,gBAA0B;AAAA;AAAA,EAEnC,KAAK,OAAO,SAAwB,SAAiB,UAAmC;AACpF,QAAI;AACA,YAAM,QAAQ,MAAM,SAAS,OAAO;AACpC,aAAO,mBAAmB,KAAK;AAAA,IACnC,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,yBAAyB,KAAK;AAChD,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAGA,eAAsB,aAAa,SAAwB,kBAAkB,OAA4B;AACrG,SAAO,SAAS,SAAS,eAAe;AAC5C;;;AClHO,IAAM,mBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AFoCzB,IAAM,iBAAiBC,GAAE,OAAO;AAAA,EACnC,SAASA,GAAE,MAAM,CAACA,GAAE,OAAO,GAAGA,GAAE,MAAMA,GAAE,OAAO,CAAC,CAAC,CAAC;AAAA,EAClD,UAAUA,GAAE,MAAM,CAACA,GAAE,OAAO,GAAGA,GAAE,MAAMA,GAAE,OAAO,CAAC,CAAC,CAAC,EAAE,QAAQ,CAAC,KAAK,CAAC;AAAA,EACpE,oBAAoBA,GAAE,QAAQ,EAAE,QAAQ,KAAK;AAAA,EAC7C,kBAAkBA,GAAE,QAAQ,EAAE,QAAQ,KAAK;AAAA,EAC3C,qBAAqBA,GAAE,QAAQ,EAAE,QAAQ,KAAK;AAAA,EAC9C,yBAAyBA,GAAE,QAAQ,EAAE,QAAQ,KAAK;AACtD,CAAC;AAIM,IAAM,oBAAoB,CAAC,QAAyC;AACvE,SAAO,eAAe,UAAU,GAAG,EAAE;AACzC;AAEA,SAAS,cAAc,OAAkC;AACrD,MAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,WAAO,MAAM,KAAK,GAAG;AAAA,EACzB;AACA,SAAO;AACX;AAEA,IAAO,mBAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAhF3B;AAiFQ,IAAAC,aAAY,IAAI,yCAAyC;AAGzD,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,MAAAA,aAAY,IAAI,4BAA4B;AAC5C,YAAM,eAAeC,gBAAe;AAAA,QAChC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,MAAAD,aAAY,IAAI,qCAAqC;AACrD,YAAM,SAAS,MAAME,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,kBAAkB,OAAO,MAAM,GAAG;AACnC,QAAAH,aAAY,MAAM,8BAA8B;AAChD,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,OAAO;AACvB,MAAAA,aAAY,IAAI,sBAAsB,OAAO;AAG7C,YAAM,aAAa,MAAM,QAAQ,QAAQ,QAAQ,IAAI,QAAQ,WAAW,CAAC,QAAQ,QAAQ;AACzF,YAAM,gBAAgB,WAAW,KAAK,GAAG,EAAE,YAAY;AAGvD,YAAM,UAAU,cAAc,QAAQ,OAAO;AAE7C,MAAAA,aAAY,IAAI,iCAAiC,EAAE,SAAS,cAAc,CAAC;AAG3E,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,aAAY,IAAI,uBAAuB,OAAO,OAAO,aAAa,KAAK;AACvE,MAAAA,aAAY,IAAI,oBAAoB,GAAG,OAAO,eAAe;AAC7D,MAAAA,aAAY,IAAI,uBAAuB;AAAA,QACnC,KAAK;AAAA,QACL;AAAA,QACA,oBAAoB,QAAQ;AAAA,QAC5B,kBAAkB,QAAQ;AAAA,QAC1B,qBAAqB,QAAQ;AAAA,QAC7B,yBAAyB,QAAQ;AAAA,MACrC,CAAC;AAED,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,QAAQ;AAAA,YACJ,KAAK;AAAA,YACL;AAAA,YACA,oBAAoB,QAAQ;AAAA,YAC5B,kBAAkB,QAAQ;AAAA,YAC1B,qBAAqB,QAAQ;AAAA,YAC7B,yBAAyB,QAAQ;AAAA,UACrC;AAAA,UACA,SAAS;AAAA,YACL,UAAU;AAAA,YACV,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,OAAO,KAAK,SAAS,IAAI,EAAE,WAAW,GAAG;AACzC,cAAM,IAAI,MAAM,8DAA8D;AAAA,MAClF;AAGA,YAAM,QAAQ,MAAM,aAAa,OAAO;AAGxC,YAAM,oBAAoB,OAAO,QAAQ,SAAS,IAAI,EAAE,IAAI,CAAC,CAAC,QAAQ,IAAI,MAAM;AAC5E,cAAM,OAAO,MAAM,KAAK,OAAK,EAAE,OAAO,MAAM;AAC5C,cAAM,WAAW,OAAO,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO,YAAY,CAAC,MAAM;AACxE,cAAM,QAAQ,CAAC,GAAG,QAAQ,GAAG;AAG7B,mBAAW,YAAY,YAAY;AAC/B,gBAAM,gBAAgB,SAAS,YAAY;AAC3C,cAAI,KAAK,QAAQ,GAAG;AAChB,kBAAM,KAAK,KAAK,aAAa,KAAK,KAAK,QAAQ,EAAE,eAAe,QAAW;AAAA,cACvE,OAAO;AAAA,cACP;AAAA,YACJ,CAAC,CAAC,EAAE;AAAA,UACR;AAGA,cAAI,QAAQ,oBAAoB;AAC5B,kBAAM,YAAY,KAAK,GAAG,QAAQ,aAAa;AAC/C,gBAAI,cAAc,QAAW;AACzB,oBAAM,KAAK,iBAAiB,aAAa,MAAM,UAAU,eAAe,QAAW;AAAA,gBAC/E,OAAO;AAAA,gBACP;AAAA,gBACA,uBAAuB;AAAA,cAC3B,CAAC,CAAC,EAAE;AAAA,YACR;AAAA,UACJ;AAGA,cAAI,QAAQ,kBAAkB;AAC1B,kBAAM,SAAS,KAAK,GAAG,QAAQ,UAAU;AACzC,gBAAI,WAAW,QAAW;AACtB,oBAAM,KAAK,iBAAiB,aAAa,MAAM,OAAO,eAAe,QAAW;AAAA,gBAC5E,OAAO;AAAA,gBACP;AAAA,gBACA,uBAAuB;AAAA,cAC3B,CAAC,CAAC,EAAE;AAAA,YACR;AAAA,UACJ;AAGA,cAAI,QAAQ,qBAAqB;AAC7B,kBAAM,SAAS,KAAK,GAAG,QAAQ,aAAa;AAC5C,gBAAI,WAAW,QAAW;AACtB,oBAAM,eAAe,UAAU,IAAI,MAAM;AACzC,oBAAM,KAAK,iBAAiB,aAAa,MAAM,YAAY,GAAG,OAAO,QAAQ,CAAC,CAAC,GAAG;AAAA,YACtF;AAAA,UACJ;AAAA,QACJ;AAGA,YAAI,QAAQ,2BAA2B,KAAK,iBAAiB;AACzD,gBAAM,cAAc,IAAI,KAAK,KAAK,kBAAkB,GAAI,EAAE,eAAe;AACzE,gBAAM,KAAK,mBAAmB,WAAW,EAAE;AAAA,QAC/C;AAEA,eAAO,MAAM,KAAK,IAAI;AAAA,MAC1B,CAAC,EAAE,OAAO,OAAO;AAEjB,UAAI,kBAAkB,WAAW,GAAG;AAChC,cAAM,IAAI,MAAM,qDAAqD;AAAA,MACzE;AAEA,YAAM,eAAe,kBAAkB,KAAK,MAAM;AAClD,MAAAJ,aAAY,QAAQ,oCAAoC;AAExD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,QAAQ,OAAO,QAAQ,SAAS,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,QAAQ,IAAI,MAAM;AAClE,oBAAM,aAAa,WAAW,OAAO,CAAC,aAAa,aAAa;AAC5D,sBAAM,eAAe;AAAA,kBACjB,OAAO,KAAK,QAAQ;AAAA,kBACpB,WAAW,KAAK,GAAG,QAAQ,aAAa;AAAA,kBACxC,WAAW,KAAK,GAAG,QAAQ,UAAU;AAAA,kBACrC,WAAW,KAAK,GAAG,QAAQ,aAAa;AAAA,kBACxC,aAAa,KAAK;AAAA,gBACtB;AACA,uBAAO,OAAO,aAAa,EAAE,CAAC,QAAQ,GAAG,aAAa,CAAC;AACvD,uBAAO;AAAA,cACX,GAAG,CAAC,CAAC;AACL,qBAAO,OAAO,KAAK,EAAE,CAAC,MAAM,GAAG,WAAW,CAAC;AAC3C,qBAAO;AAAA,YACX,GAAG,CAAC,CAAC;AAAA,YACL,QAAQ;AAAA,cACJ,YAAY,WAAW,IAAI,OAAK,EAAE,YAAY,CAAC;AAAA,cAC/C,oBAAoB,QAAQ;AAAA,cAC5B,kBAAkB,QAAQ;AAAA,cAC1B,qBAAqB,QAAQ;AAAA,cAC7B,yBAAyB,QAAQ;AAAA,YACrC;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,+BAA+B,KAAK;AAEtD,UAAI;AACJ,YAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAChC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,YAC5B,SAAQ,WAAM,WAAN,mBAAc;AAAA,YACtB,mBAAiB,WAAM,aAAN,mBAAgB,YAAW;AAAA,UAChD;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AG5UA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,4BAA4B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADmBlC,IAAM,sBAAsBC,GAAE,OAAO;AAAA,EACxC,SAASA,GAAE,OAAO;AAAA,EAClB,cAAcA,GAAE,OAAO;AAC3B,CAAC;AAKM,IAAM,yBAAyB,CAClC,QAC8B;AAC9B,SAAO,oBAAoB,UAAU,GAAG,EAAE;AAC9C;AAgBA,IAAO,6BAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aACI;AAAA,EACJ,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAnE3B;AAoEQ,IAAAC,aAAY,IAAI,gDAAgD;AAGhE,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,MAAAA,aAAY,IAAI,kCAAkC;AAClD,YAAM,UAAUC,gBAAe;AAAA,QAC3B,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,MAAAD,aAAY,IAAI,qCAAqC;AACrD,YAAM,SAAS,MAAME,gBAAe;AAAA,QAChC;AAAA,QACA;AAAA,QACA,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,uBAAuB,OAAO,MAAM,GAAG;AACxC,QAAAH,aAAY,MAAM,oCAAoC;AACtD,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,OAAO;AACvB,MAAAA,aAAY,IAAI,sBAAsB,OAAO;AAG7C,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAG1D,MAAAA,aAAY,IAAI,wBAAwB;AACxC,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO,UAAU,QAAQ,OAAO,aAAa,QAAQ,YAAY;AAAA,QACpE;AAAA,UACI,SAAS;AAAA,YACL,QAAQ;AAAA,YACR,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,YAAM,YAAY,SAAS;AAC3B,UAAI,GAAC,qBAAU,gBAAV,mBAAuB,kBAAvB,mBAAsC,MAAK;AAC5C,cAAM,IAAI;AAAA,UACN,qCAAqC,QAAQ,YAAY,OAAO,QAAQ,OAAO;AAAA,QACnF;AAAA,MACJ;AAGA,YAAM,QAAQ;AAAA,QACV,GAAG,UAAU,IAAI,KAAK,UAAU,OAAO,YAAY,CAAC;AAAA,QACpD,YAAY,QAAQ,YAAY;AAAA,QAChC,UAAU,QAAQ,OAAO;AAAA,QACzB,WAAW,UAAU,YAAY,cAAc,IAAI,QAAQ,CAAC,CAAC;AAAA,MACjE;AAEA,WAAI,eAAU,YAAY,eAAtB,mBAAkC,KAAK;AACvC,cAAM;AAAA,UACF,gBAAgB,UAAU,YAAY,WAAW,IAAI,eAAe,CAAC;AAAA,QACzE;AAAA,MACJ;AAEA,YAAM,eAAe,MAAM,KAAK,IAAI;AACpC,MAAAJ,aAAY,QAAQ,0CAA0C;AAE9D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO;AAAA,cACH,MAAM,UAAU;AAAA,cAChB,QAAQ,UAAU;AAAA,cAClB,SAAS,QAAQ;AAAA,cACjB,OAAO,QAAQ;AAAA,cACf,OAAO,UAAU,YAAY,cAAc;AAAA,cAC3C,YAAW,eAAU,YAAY,eAAtB,mBAAkC;AAAA,YACjD;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY;AAAA,QACR;AAAA,QACA;AAAA,MACJ;AAEA,UAAI;AACJ,YAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAChC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBACI;AAAA,MACR,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBACI;AAAA,MACR,OAAO;AACH,uBACI;AAAA,MACR;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,YAC5B,mBAAiB,WAAM,aAAN,mBAAgB,YAAW;AAAA,UAChD;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AExNA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,8BAA8B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADwC3C,IAAM,eAAeC,GAAE,KAAK,CAAC,MAAM,OAAO,MAAM,OAAO,OAAO,OAAO,IAAI,CAAC;AAGnE,IAAM,4BAA4BA,GAAE,OAAO;AAAA,EAC9C,aAAaA,GAAE,OAAO,EAAE,QAAQ,KAAK;AAAA,EACrC,UAAU,aAAa,QAAQ,KAAK;AAAA,EACpC,WAAWA,GAAE,OAAO,EAAE,QAAQ,MAAM;AACxC,CAAC;AAIM,IAAM,+BAA+B,CAAC,QAAoD;AAC7F,SAAO,0BAA0B,UAAU,GAAG,EAAE;AACpD;AAEA,IAAO,8BAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AA5E3B;AA6EQ,IAAAC,aAAY,IAAI,sDAAsD;AAGtE,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,MAAAA,aAAY,IAAI,qCAAqC;AACrD,YAAM,UAAUC,gBAAe;AAAA,QAC3B,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,MAAAD,aAAY,IAAI,qCAAqC;AACrD,YAAM,SAAS,MAAME,gBAAe;AAAA,QAChC;AAAA,QACA;AAAA,QACA,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,6BAA6B,OAAO,MAAM,GAAG;AAC9C,QAAAH,aAAY,MAAM,uCAAuC;AACzD,eAAO;AAAA,MACX;AAEA,YAAM,UAAU,OAAO;AACvB,MAAAA,aAAY,IAAI,sBAAsB,OAAO;AAG7C,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,aAAY,IAAI,qCAAqC;AACrD,MAAAA,aAAY,IAAI,uBAAuB;AAAA,QACnC,aAAa,QAAQ;AAAA,QACrB,UAAU,QAAQ;AAAA,QAClB,WAAW,QAAQ;AAAA,MACvB,CAAC;AAED,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,SAAS;AAAA,YACL,UAAU;AAAA,YACV,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,UACA,QAAQ;AAAA,YACJ,aAAa,QAAQ;AAAA,YACrB,UAAU,QAAQ;AAAA,YAClB,WAAW,QAAQ;AAAA,UACvB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAGA,YAAM,eAAe;AAAA,QACjB;AAAA,QACA,GAAG,SAAS,KAAK,YAAY,IAAI,CAAC,MAAM,UAAU;AAC9C,gBAAM,YAAY,OAAO,QAAQ,QAAQ;AACzC,gBAAM,SAAS,KAAK,SAAS;AAC7B,iBAAO,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,OAAO,YAAY,CAAC,QACpD,KAAK,IAAI,eAAe,QAAW,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,CAAC,MAC3F,UAAU,IAAI,MAAM,EAAE,GAAG,OAAO,QAAQ,CAAC,CAAC,IAC7C,KAAK,kBAAkB,YAAY,KAAK,eAAe,KAAK,EAAE;AAAA,QACzE,CAAC;AAAA,QACD;AAAA,QACA;AAAA,QACA,GAAG,SAAS,KAAK,WAAW,IAAI,CAAC,MAAM,UAAU;AAC7C,gBAAM,YAAY,OAAO,QAAQ,QAAQ;AACzC,gBAAM,SAAS,KAAK,SAAS;AAC7B,iBAAO,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,OAAO,YAAY,CAAC,QACpD,KAAK,IAAI,eAAe,QAAW,EAAE,uBAAuB,GAAG,uBAAuB,EAAE,CAAC,CAAC,MAC3F,UAAU,IAAI,MAAM,EAAE,GAAG,OAAO,QAAQ,CAAC,CAAC,IAC7C,KAAK,kBAAkB,YAAY,KAAK,eAAe,KAAK,EAAE;AAAA,QACzE,CAAC;AAAA,MACL,EAAE,KAAK,IAAI;AAEX,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,MAAM,SAAS;AAAA,YACf,QAAQ;AAAA,cACJ,aAAa,QAAQ;AAAA,cACrB,UAAU,QAAQ;AAAA,cAClB,WAAW,QAAQ;AAAA,YACvB;AAAA,UACJ;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAJ,aAAY,MAAM,4CAA4C,KAAK;AAEnE,UAAI;AACJ,YAAI,WAAM,aAAN,mBAAgB,YAAW,KAAK;AAChC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB,aAAW,WAAM,aAAN,mBAAgB,YAAW,KAAK;AACvC,uBAAe;AAAA,MACnB,OAAO;AACH,uBAAe,2CAA2C,MAAM,OAAO;AAAA,MAC3E;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,YAC5B,SAAQ,WAAM,WAAN,mBAAc;AAAA,YACtB,mBAAiB,WAAM,aAAN,mBAAgB,YAAW;AAAA,UAChD;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AE5PA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADwD5B,IAAM,oBAAoBC,GAAE,OAAO;AAAA,EACtC,cAAcA,GAAE,QAAQ,EAAE,QAAQ,IAAI;AAAA,EACtC,oBAAoBA,GAAE,QAAQ,EAAE,QAAQ,IAAI;AAChD,CAAC;AAIM,IAAM,uBAAuB,CAAC,QAA4C;AAC7E,SAAO,kBAAkB,UAAU,GAAG,EAAE;AAC5C;AAEA,IAAO,sBAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA;AAAA,EAEA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAxF3B;AAyFQ,IAAAC,aAAY,IAAI,4CAA4C;AAG5D,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AAEA,MAAAA,aAAY,IAAI,+BAA+B;AAC/C,YAAM,kBAAkBC,gBAAe;AAAA,QACnC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,YAAM,SAAS,MAAMC,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,qBAAqB,OAAO,MAAM,GAAG;AACtC,QAAAH,aAAY,MAAM,iCAAiC;AACnD,eAAO;AAAA,MACX;AAGA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,aAAY,IAAI,2BAA2B;AAE3C,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,SAAS;AAAA,YACL,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,YAAM,gBAAgB;AAAA,QAClB,OAAO,SAAS,KAAK,MAAM,IAAI,CAAC,EAAE,KAAK,OAAO;AAAA,UAC1C,MAAM,KAAK;AAAA,UACX,QAAQ,KAAK,OAAO,YAAY;AAAA,UAChC,eAAe,KAAK;AAAA,UACpB,IAAI,KAAK;AAAA,UACT,WAAW,KAAK;AAAA,UAChB,YAAY,KAAK;AAAA,QACrB,EAAE;AAAA,QACF,MAAM,SAAS,KAAK,KAAK,IAAI,UAAQ;AAAA,UACjC,MAAM,IAAI;AAAA,UACV,QAAQ,IAAI;AAAA,UACZ,IAAI,IAAI;AAAA,UACR,WAAW,IAAI;AAAA,QACnB,EAAE;AAAA,QACF,YAAY,SAAS,KAAK,WAAW,IAAI,eAAa;AAAA,UAClD,MAAM,SAAS;AAAA,UACf,IAAI,SAAS;AAAA,QACjB,EAAE;AAAA,MACN;AAEA,YAAM,eAAe;AAAA,QACjB;AAAA,QACA,GAAG,cAAc,MAAM;AAAA,UAAI,CAAC,MAAM,UAC9B,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM,IAAI,KAAK,gBAAgB,YAAY,KAAK,aAAa,KAAK,EAAE;AAAA,QAC5G;AAAA,QACA;AAAA,QACA;AAAA,QACA,GAAI,cAAc,KAAK,SACnB,cAAc,KAAK,IAAI,CAAC,KAAK,UAAU,GAAG,QAAQ,CAAC,KAAK,IAAI,IAAI,KAAK,IAAI,MAAM,GAAG,IAClF,CAAC,4BAA4B;AAAA,QACjC;AAAA,QACA;AAAA,QACA,GAAI,cAAc,WAAW,SACzB,cAAc,WAAW,IAAI,CAAC,UAAU,UAAU,GAAG,QAAQ,CAAC,KAAK,SAAS,IAAI,EAAE,IAClF,CAAC,kCAAkC;AAAA,MAC3C,EAAE,KAAK,IAAI;AAEX,MAAAJ,aAAY,QAAQ,uCAAuC;AAE3D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,UAAU;AAAA,YACV,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,kCAAkC,KAAK;AAGzD,YAAM,iBAAe,WAAM,aAAN,mBAAgB,YAAW,MAC5C,iDACA,iCAAiC,MAAM,OAAO;AAElD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AE/PA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,2BAA2B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADkCjC,IAAM,yBAAyBC,GAAE,OAAO;AAAA,EAC3C,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG,EAAE,QAAQ,EAAE;AAChD,CAAC;AAKM,IAAM,4BAA4B,CACrC,QACiC;AACjC,SAAO,uBAAuB,UAAU,GAAG,EAAE;AACjD;AAEA,IAAO,2BAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS,CAAC,kBAAkB,aAAa,iBAAiB,WAAW;AAAA,EACrE,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AA7D3B;AA8DQ,IAAAC,aAAY,IAAI,kDAAkD;AAGlE,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,MAAAA,aAAY,IAAI,qCAAqC;AACrD,YAAM,kBAAkBC,gBAAe;AAAA,QACnC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,YAAM,SAAS,MAAMC,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,0BAA0B,OAAO,MAAM,GAAG;AAC3C,QAAAH,aAAY,MAAM,uCAAuC;AACzD,eAAO;AAAA,MACX;AAGA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,aAAY,IAAI,iCAAiC;AAEjD,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,SAAS;AAAA,YACL,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,YAAM,gBAAgB,SAAS,KAAK,KAAK,IAAI,CAAC,UAAU;AAAA,QACpD,MAAM,KAAK,WAAW;AAAA,QACtB,WAAW;AAAA,UACP,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,KAAK,OAAO,KAAK,WAAW,OAAO,EAAE,eAAe,SAAS;AAAA,UACzD,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,YAAY;AAAA,UACR,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,WAAW,IAAI;AAAA,UACX,KAAK,WAAW;AAAA,QACpB,EAAE,mBAAmB;AAAA,MACzB,EAAE;AAEF,YAAM,eAAe;AAAA,QACjB;AAAA,QACA;AAAA,QACA,GAAG,cAAc;AAAA,UAAI,CAAC,MAAM,UACxB;AAAA,YACI,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI;AAAA,YAC1B,kBAAkB,KAAK,SAAS;AAAA,YAChC,WAAW,KAAK,GAAG;AAAA,YACnB,eAAe,KAAK,UAAU;AAAA,YAC9B,eAAe,KAAK,SAAS;AAAA,YAC7B;AAAA,UACJ,EAAE,KAAK,IAAI;AAAA,QACf;AAAA,MACJ,EAAE,KAAK,IAAI;AAEX,MAAAJ,aAAY,QAAQ,6CAA6C;AAEjE,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,eAAe;AAAA,YACf,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,wCAAwC,KAAK;AAE/D,YAAM,iBACF,WAAM,aAAN,mBAAgB,YAAW,MACrB,iDACA,uCAAuC,MAAM,OAAO;AAE9D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AExPA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,YAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,sBAAsB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AD2B5B,IAAM,oBAAoBC,GAAE,OAAO;AAAA,EACtC,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,EAAE,EAAE,QAAQ,EAAE;AAC/C,CAAC;AAIM,IAAM,uBAAuB,CAAC,QAA4C;AAC7E,SAAO,kBAAkB,UAAU,GAAG,EAAE;AAC5C;AAEA,IAAO,yBAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aAAa;AAAA,EACb,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAxD3B;AAyDQ,IAAAC,aAAY,IAAI,6CAA6C;AAG7D,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAGA,QAAI;AACA,MAAAA,aAAY,IAAI,gCAAgC;AAChD,YAAM,kBAAkBC,gBAAe;AAAA,QACnC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,YAAM,SAAS,MAAMC,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,qBAAqB,OAAO,MAAM,GAAG;AACtC,QAAAH,aAAY,MAAM,kCAAkC;AACpD,eAAO;AAAA,MACX;AAGA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,aAAY,IAAI,4BAA4B;AAE5C,YAAM,WAAW,MAAMI,OAAM;AAAA,QACzB,GAAG,OAAO;AAAA,QACV;AAAA,UACI,SAAS;AAAA,YACL,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,YAAM,gBAAgB,SAAS,KAC1B,MAAM,GAAG,OAAO,OAAO,KAAK,EAC5B,IAAI,WAAS;AAAA,QACV,MAAM,KAAK;AAAA,QACX,QAAQ,KAAK,OAAO,YAAY;AAAA,QAChC,aAAa,IAAI,KAAK,KAAK,eAAe,GAAI,EAAE,eAAe,SAAS;AAAA,UACpE,MAAM;AAAA,UACN,OAAO;AAAA,UACP,KAAK;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ,CAAC;AAAA,MACL,EAAE;AAEN,YAAM,eAAe;AAAA,QACjB;AAAA,QACA;AAAA,QACA,GAAG,cAAc;AAAA,UAAI,CAAC,MAAM,UACxB,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI,KAAK,KAAK,MAAM;AAAA,aAAiB,KAAK,WAAW;AAAA,QAC/E;AAAA,MACJ,EAAE,KAAK,IAAI;AAEX,MAAAJ,aAAY,QAAQ,wCAAwC;AAE5D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,UAAU;AAAA,YACV,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,aAAY,MAAM,mCAAmC,KAAK;AAE1D,YAAM,iBAAe,WAAM,aAAN,mBAAgB,YAAW,MAC5C,iDACA,kCAAkC,MAAM,OAAO;AAEnD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AExLA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,aAAW;AAClB,SAAS,KAAAC,UAAS;;;ACdX,IAAM,kCAAkC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACA/C;AAAA,EAKI,eAAAC;AAAA,OACG;AACP,OAAOC,aAAW;AAkBlB,IAAMC,aAAY;AAClB,IAAMC,aAAY,KAAK;AACvB,IAAMC,eAAc;AAEpB,eAAe,cAAc,SAAgD;AA7B7E;AA8BI,QAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,QAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,QAAM,WAAW,MAAMC,QAAM;AAAA,IACzB,GAAG,OAAO;AAAA,IACV;AAAA,MACI,SAAS;AAAA,QACL,QAAQ;AAAA,QACR,CAAC,SAAS,GAAG;AAAA,MACjB;AAAA,MACA,SAAS;AAAA;AAAA,IACb;AAAA,EACJ;AAEA,MAAI,GAAC,oBAAS,SAAT,mBAAe,SAAf,mBAAqB,SAAQ;AAC9B,UAAM,IAAI,MAAM,gCAAgC;AAAA,EACpD;AAEA,SAAO,SAAS,KAAK;AACzB;AAEA,eAAeC,gBAAe,SAAgD;AAC1E,MAAI,YAA0B;AAE9B,WAAS,IAAI,GAAG,IAAIF,cAAa,KAAK;AAClC,QAAI;AACA,aAAO,MAAM,cAAc,OAAO;AAAA,IACtC,SAAS,OAAO;AACZ,kBAAY;AACZ,MAAAG,cAAY,MAAM,0BAA0B,IAAI,CAAC,YAAY,KAAK;AAClE,YAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,OAAQ,IAAI,EAAE,CAAC;AAAA,IACtE;AAAA,EACJ;AAEA,QACI,aACA,IAAI,MAAM,kDAAkD;AAEpE;AAEA,eAAe,YAAY,SAAgD;AACvE,MAAI;AAEA,UAAM,SAAS,MAAM,QAAQ,aAAa,IAAmBL,UAAS;AACtE,QAAI,QAAQ;AACR,aAAO;AAAA,IACX;AAGA,UAAM,WAAW,MAAMI,gBAAe,OAAO;AAG7C,UAAM,QAAQ,aAAa,IAAIJ,YAAW,UAAU;AAAA,MAChD,SAASC;AAAA,IACb,CAAC;AAED,WAAO;AAAA,EACX,SAAS,OAAO;AACZ,IAAAI,cAAY,MAAM,4BAA4B,KAAK;AACnD,UAAM;AAAA,EACV;AACJ;AAEA,SAAS,sBAAsB,UAAiC;AAC5D,QAAM,eAAe,CAAC,OAAO,OAAO,eAAe,QAAQ,QAAQ;AAEnE,QAAM,UAAU,SACX,OAAO,CAAC,MAAM,aAAa,SAAS,EAAE,EAAE,CAAC,EACzC,IAAI,CAAC,MAAM,GAAG,EAAE,WAAW,IAAI,UAAU,EAAE,EAAE,EAAE;AAEpD,SAAO;AAAA;AAAA;AAAA;AAAA,EAIT,QAAQ,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE,EAAE,KAAK,IAAI,CAAC;AAAA;AAAA,4BAEb,SAAS,MAAM;AAAA;AAAA;AAAA,EAGzC,KAAK;AACP;AAEO,IAAM,mBAA6B;AAAA;AAAA,EAEtC,KAAK,OACD,SACA,SACA,UACkB;AAClB,QAAI;AACA,YAAM,WAAW,MAAM,YAAY,OAAO;AAC1C,aAAO,sBAAsB,QAAQ;AAAA,IACzC,SAAS,OAAO;AACZ,MAAAA,cAAY,MAAM,4BAA4B,KAAK;AACnD,aAAO;AAAA,IACX;AAAA,EACJ;AACJ;AAGA,eAAsB,gBAClB,SACsB;AACtB,SAAO,YAAY,OAAO;AAC9B;;;AFnGO,IAAM,gCAAgCC,GAAE,OAAO;AAAA,EAClD,WAAWA,GAAE,OAAO;AAAA,EACpB,OAAOA,GAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG,EAAE,QAAQ,EAAE;AAChD,CAAC;AAOM,IAAM,mCAAmC,CAC5C,QACwC;AACxC,SAAO,8BAA8B,UAAU,GAAG,EAAE;AACxD;AAEA,IAAO,kCAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aACI;AAAA,EACJ,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAtE3B;AAuEQ,IAAAC,cAAY;AAAA,MACR;AAAA,IACJ;AAEA,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAEA,QAAI;AACA,MAAAA,cAAY,IAAI,6CAA6C;AAC7D,YAAM,kBAAkBC,gBAAe;AAAA,QACnC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,YAAM,SAAS,MAAMC,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,iCAAiC,OAAO,MAAM,GAAG;AAClD,QAAAH,cAAY;AAAA,UACR;AAAA,QACJ;AACA,eAAO;AAAA,MACX;AAGA,YAAM,WAAW,MAAM,gBAAgB,OAAO;AAG9C,YAAM,UAAU,SAAS,KAAK,CAAC,MAAM;AACjC,cAAM,aACF,OAAO,OACT,UAAU,YAAY;AACxB,eACI,EAAE,GAAG,YAAY,MAAM,cACvB,EAAE,WAAW,KAAK,YAAY,EAAE,SAAS,UAAU,KACnD,EAAE,WAAW,4BAA4B,YAAY,MACjD;AAAA,MAEZ,CAAC;AAED,UAAI,CAAC,SAAS;AACV,cAAM,IAAI;AAAA,UACN,WAAW,OAAO,OAAO,SAAS;AAAA,QACtC;AAAA,MACJ;AAEA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,cAAY;AAAA,QACR,6CAA6C,QAAQ,EAAE;AAAA,MAC3D;AAEA,YAAM,WAAW,MAAMI,QAAM;AAAA,QACzB,GAAG,OAAO,qBAAqB,QAAQ,EAAE;AAAA,QACzC;AAAA,UACI,SAAS;AAAA,YACL,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,YAAM,gBAAgB,SAAS,KAAK,KAC/B,MAAM,GAAG,OAAO,OAAO,KAAK,EAC5B,IAAI,CAAC,UAAU;AAAA,QACZ,MAAM,KAAK,WAAW;AAAA,QACtB,WAAW;AAAA,UACP,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,KAAK,OAAO,KAAK,WAAW,OAAO,EAAE;AAAA,UACjC;AAAA,UACA;AAAA,YACI,OAAO;AAAA,YACP,UAAU;AAAA,UACd;AAAA,QACJ;AAAA,QACA,YAAY;AAAA,UACR,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,WAAW,IAAI;AAAA,UACX,KAAK,WAAW;AAAA,QACpB,EAAE,mBAAmB;AAAA,MACzB,EAAE;AAEN,YAAM,eAAe;AAAA,QACjB,+BAA+B,QAAQ,WAAW,IAAI;AAAA,QACtD;AAAA,QACA,GAAG,cAAc;AAAA,UAAI,CAAC,MAAM,UACxB;AAAA,YACI,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI;AAAA,YAC1B,kBAAkB,KAAK,SAAS;AAAA,YAChC,WAAW,KAAK,GAAG;AAAA,YACnB,eAAe,KAAK,UAAU;AAAA,YAC9B,eAAe,KAAK,SAAS;AAAA,YAC7B;AAAA,UACJ,EAAE,KAAK,IAAI;AAAA,QACf;AAAA,MACJ,EAAE,KAAK,IAAI;AAEX,MAAAJ,cAAY;AAAA,QACR;AAAA,MACJ;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,WAAW,QAAQ;AAAA,YACnB,aAAa,QAAQ,WAAW;AAAA,YAChC,eAAe;AAAA,YACf,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,cAAY;AAAA,QACR;AAAA,QACA;AAAA,MACJ;AAEA,YAAM,iBACF,WAAM,aAAN,mBAAgB,YAAW,MACrB,iDACA,uCAAuC,MAAM,OAAO;AAE9D,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AGtSA;AAAA,EAEI,kBAAAK;AAAA,EAEA,eAAAC;AAAA,EACA,kBAAAC;AAAA,EAIA,cAAAC;AAAA,OAGG;AACP,OAAOC,aAAW;AAClB,SAAS,KAAAC,WAAS;;;ACdX,IAAM,6BAA6B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ADmCnC,IAAM,2BAA2BC,IAAE,OAAO;AAAA,EAC7C,WAAWA,IAAE,OAAO;AAAA,EACpB,OAAOA,IAAE,OAAO,EAAE,IAAI,CAAC,EAAE,IAAI,GAAG,EAAE,QAAQ,EAAE;AAChD,CAAC;AAOM,IAAM,8BAA8B,CACvC,QACmC;AACnC,SAAO,yBAAyB,UAAU,GAAG,EAAE;AACnD;AAEA,IAAO,6BAAQ;AAAA,EACX,MAAM;AAAA,EACN,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,UAAU,OAAO,SAAwB,aAAqB;AAC1D,UAAM,wBAAwB,OAAO;AACrC,WAAO;AAAA,EACX;AAAA,EACA,aACI;AAAA,EACJ,SAAS,OACL,SACA,SACA,OACA,UACA,aACmB;AAxE3B;AAyEQ,IAAAC,cAAY,IAAI,qDAAqD;AAErE,QAAI,eAAe;AACnB,QAAI,CAAC,cAAc;AACf,qBAAgB,MAAM,QAAQ,aAAa,OAAO;AAAA,IACtD,OAAO;AACH,qBAAe,MAAM,QAAQ,yBAAyB,YAAY;AAAA,IACtE;AAEA,QAAI;AACA,MAAAA,cAAY,IAAI,wCAAwC;AACxD,YAAM,kBAAkBC,gBAAe;AAAA,QACnC,OAAO;AAAA,QACP,UAAU;AAAA,MACd,CAAC;AAED,YAAM,SAAS,MAAMC,gBAAe;AAAA,QAChC;AAAA,QACA,SAAS;AAAA,QACT,YAAYC,YAAW;AAAA,QACvB,QAAQ;AAAA,MACZ,CAAC;AAED,UAAI,CAAC,4BAA4B,OAAO,MAAM,GAAG;AAC7C,QAAAH,cAAY,MAAM,0CAA0C;AAC5D,eAAO;AAAA,MACX;AAGA,YAAM,WAAW,MAAM,gBAAgB,OAAO;AAG9C,YAAM,mBAAmB,MAAM,gBAAgB,OAAO;AAGtD,YAAM,UAAU,iBAAiB,KAAK,CAAC,MAAM;AACzC,cAAM,aACF,OAAO,OACT,UAAU,YAAY;AACxB,eACI,EAAE,GAAG,YAAY,MAAM,cACvB,EAAE,WAAW,KAAK,YAAY,EAAE,SAAS,UAAU,KACnD,EAAE,WAAW,4BAA4B,YAAY,MACjD;AAAA,MAEZ,CAAC;AAED,UAAI,CAAC,SAAS;AACV,cAAM,IAAI;AAAA,UACN,WAAW,OAAO,OAAO,SAAS;AAAA,QACtC;AAAA,MACJ;AAEA,YAAM,SAAS,MAAM,wBAAwB,OAAO;AACpD,YAAM,EAAE,SAAS,QAAQ,UAAU,IAAI,aAAa,MAAM;AAE1D,MAAAA,cAAY;AAAA,QACR,wCAAwC,QAAQ,EAAE;AAAA,MACtD;AAEA,YAAM,WAAW,MAAMI,QAAM;AAAA,QACzB,GAAG,OAAO,qBAAqB,QAAQ,EAAE;AAAA,QACzC;AAAA,UACI,SAAS;AAAA,YACL,CAAC,SAAS,GAAG;AAAA,UACjB;AAAA,QACJ;AAAA,MACJ;AAEA,UAAI,CAAC,SAAS,MAAM;AAChB,cAAM,IAAI,MAAM,qCAAqC;AAAA,MACzD;AAEA,YAAM,gBAAgB,SAAS,KAAK,KAC/B,MAAM,GAAG,OAAO,OAAO,KAAK,EAC5B,IAAI,CAAC,UAAU;AAAA,QACZ,MAAM,KAAK,WAAW;AAAA,QACtB,WAAW;AAAA,UACP,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,KAAK,OAAO,KAAK,WAAW,OAAO,EAAE;AAAA,UACjC;AAAA,UACA;AAAA,YACI,OAAO;AAAA,YACP,UAAU;AAAA,UACd;AAAA,QACJ;AAAA,QACA,YAAY;AAAA,UACR,KAAK,WAAW;AAAA,QACpB,EAAE,eAAe,SAAS;AAAA,UACtB,OAAO;AAAA,UACP,UAAU;AAAA,QACd,CAAC;AAAA,QACD,WAAW,IAAI;AAAA,UACX,KAAK,WAAW;AAAA,QACpB,EAAE,mBAAmB;AAAA,MACzB,EAAE;AAEN,YAAM,eAAe;AAAA,QACjB,0BAA0B,QAAQ,WAAW,IAAI;AAAA,QACjD;AAAA,QACA,GAAG,cAAc;AAAA,UAAI,CAAC,MAAM,UACxB;AAAA,YACI,GAAG,QAAQ,CAAC,KAAK,KAAK,IAAI;AAAA,YAC1B,kBAAkB,KAAK,SAAS;AAAA,YAChC,WAAW,KAAK,GAAG;AAAA,YACnB,eAAe,KAAK,UAAU;AAAA,YAC9B,eAAe,KAAK,SAAS;AAAA,YAC7B;AAAA,UACJ,EAAE,KAAK,IAAI;AAAA,QACf;AAAA,MACJ,EAAE,KAAK,IAAI;AAEX,MAAAJ,cAAY;AAAA,QACR;AAAA,MACJ;AAEA,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,WAAW,QAAQ;AAAA,YACnB,aAAa,QAAQ,WAAW;AAAA,YAChC,UAAU;AAAA,YACV,YAAW,oBAAI,KAAK,GAAE,YAAY;AAAA,UACtC;AAAA,QACJ,CAAC;AAAA,MACL;AAEA,aAAO;AAAA,IACX,SAAS,OAAO;AACZ,MAAAA,cAAY,MAAM,2CAA2C,KAAK;AAElE,YAAM,iBACF,WAAM,aAAN,mBAAgB,YAAW,MACrB,iDACA,kCAAkC,MAAM,OAAO;AAEzD,UAAI,UAAU;AACV,iBAAS;AAAA,UACL,MAAM;AAAA,UACN,SAAS;AAAA,YACL,OAAO,MAAM;AAAA,YACb,aAAY,WAAM,aAAN,mBAAgB;AAAA,UAChC;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EAEA,UAAU;AAAA,IACN;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,IACA;AAAA,MACI;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,UACN,QAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA;AAAA,QACI,MAAM;AAAA,QACN,SAAS;AAAA,UACL,MAAM;AAAA,QACV;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AACJ;;;AEvRO,IAAM,kBAAkB;AAAA,EAC3B,MAAM;AAAA,EACN,aAAa;AAAA,EACb,SAAS;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AAAA,EACA,YAAY,CAAC;AAAA,EACb,WAAW,CAAC,oBAAoB,eAAe,gBAAgB;AACnE;AAEA,IAAO,gBAAQ;","names":["elizaLogger","axios","z","z","elizaLogger","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","elizaLogger","axios","CACHE_KEY","CACHE_TTL","MAX_RETRIES","axios","fetchWithRetry","elizaLogger","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","elizaLogger","axios","CACHE_KEY","CACHE_TTL","MAX_RETRIES","axios","fetchWithRetry","elizaLogger","z","elizaLogger","composeContext","generateObject","ModelClass","axios","composeContext","elizaLogger","generateObject","ModelClass","axios","z","z","elizaLogger","composeContext","generateObject","ModelClass","axios"]}